{
  "iri": "Paper-Active_knowledge_graph_completion",
  "title": "Active knowledge graph completion",
  "authors": [
    "Pouya Ghiasnezhad Omran",
    "Kerry Taylor",
    "Sergio Rodriguez Mendez",
    "Armin Haller"
  ],
  "keywords": [
    "Existential rule learning",
    "Knowledge graph completion",
    "Rule learning",
    "Knowledge graph"
  ],
  "sections": [
    {
      "iri": "Section-1",
      "subtitle": "Abstract",
      "paragraphs": [
        {
          "iri": "Section-1-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-1-Paragraph-1-Sentence-1",
              "text": "Enterprise and public Knowledge Graphs (KGs) are known to be incomplete."
            },
            {
              "iri": "Section-1-Paragraph-1-Sentence-2",
              "text": "Methods for automatic completion, sometimes by rule learning, scale well."
            },
            {
              "iri": "Section-1-Paragraph-1-Sentence-3",
              "text": "While previous rule-based methods learn closed (non-existential) rules, we introduce Open Path (OP) rules that are constrained existential rules."
            },
            {
              "iri": "Section-1-Paragraph-1-Sentence-4",
              "text": "We present a novel algorithm, OPRL, for learning OP rules."
            }
          ]
        },
        {
          "iri": "Section-1-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-1-Paragraph-2-Sentence-1",
              "text": "Closed rules complete a KG by answering queries of unclear origin, usually derived from a holdback test set in experimental settings."
            },
            {
              "iri": "Section-1-Paragraph-2-Sentence-2",
              "text": "However, OP rules can generate relevant queries for KG completion."
            },
            {
              "iri": "Section-1-Paragraph-2-Sentence-3",
              "text": "OPRL generates queries even when there is no closed rule to answer the query, or when the correct answer is a missing entity that is not present in the KG."
            }
          ]
        },
        {
          "iri": "Section-1-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-1-Paragraph-3-Sentence-1",
              "text": "For OPRL to scale well, we propose a novel embedding-based fitness function to efficiently estimate rule quality."
            },
            {
              "iri": "Section-1-Paragraph-3-Sentence-2",
              "text": "Additionally, we introduce a novel, efficient vector computation to formally assess rule quality."
            }
          ]
        },
        {
          "iri": "Section-1-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-1-Paragraph-4-Sentence-1",
              "text": "We evaluate OPRL using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG."
            },
            {
              "iri": "Section-1-Paragraph-4-Sentence-2",
              "text": "We find that OPRL mines hundreds of accurate rules from massive KGs with up to 8 M facts."
            },
            {
              "iri": "Section-1-Paragraph-4-Sentence-3",
              "text": "The OP rules generate queries with precision as high as 98% and recall of 62% on a complete KG, demonstrating the first solution for active knowledge graph completion."
            }
          ]
        },
        {
          "iri": "Section-1-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-1-Paragraph-5-Sentence-1",
              "text": "Crown Copyright 2022 Published by Elsevier Inc."
            },
            {
              "iri": "Section-1-Paragraph-5-Sentence-2",
              "text": "This is an open access article under the"
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-2",
      "subtitle": "Introduction",
      "paragraphs": [
        {
          "iri": "Section-2-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-1-Sentence-1",
              "text": "Knowledge Graphs (KGs) are a convenient technology to model and store massive quantities of weakly-structured data."
            },
            {
              "iri": "Section-2-Paragraph-1-Sentence-2",
              "text": "The power of KGs arises from a data-first approach."
            },
            {
              "iri": "Section-2-Paragraph-1-Sentence-3",
              "text": "They allow information to be added in a relatively arbitrary manner as structural constraints are few; unlike, for example, relational databases where type, not-null, and key constraints abound to enforce a kind of completeness."
            },
            {
              "iri": "Section-2-Paragraph-1-Sentence-4",
              "text": "However, the intended scope of KGs is usually poorly defined and they fail to record relevant entities, as well as relevant relationships for the entities they do record."
            },
            {
              "iri": "Section-2-Paragraph-1-Sentence-5",
              "text": "This is just like in Wikipedia, where some topics are more richly covered than others."
            },
            {
              "iri": "Section-2-Paragraph-1-Sentence-6",
              "text": "Even for the same topic area, say movie actors for instance, we have much better coverage for the movies produced in some countries than we do for others."
            },
            {
              "iri": "Section-2-Paragraph-1-Sentence-7",
              "text": "KGs are often (semi-) automatically built from unstructured sources such as Wikipedia articles."
            },
            {
              "iri": "Section-2-Paragraph-1-Sentence-8",
              "text": "The building methods are prone to asserting some erroneous facts, while missing some others."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-2-Sentence-1",
              "text": "Techniques have been developed for knowledge graph completion and rule learning to curate KGs automatically."
            },
            {
              "iri": "Section-2-Paragraph-2-Sentence-2",
              "text": "In these approaches, models, often expressed as logical rules or vector embeddings, are learnt from a given KG."
            },
            {
              "iri": "Section-2-Paragraph-2-Sentence-3",
              "text": "The models are then used for curating tasks including link prediction that predict missing facts about extant entities."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-3-Sentence-1",
              "text": "Rule learning methods for KGs consider Closed (non-existential) rules which are used to predict a fact that instantiates the triple at the head of the rule."
            },
            {
              "iri": "Section-2-Paragraph-3-Sentence-2",
              "text": "For example, consider a rule defining a relationship between citizenship and the residence of a person, citizenOf(x, y) livesIn(x, z) ^ locatedIn(z, y)."
            },
            {
              "iri": "Section-2-Paragraph-3-Sentence-3",
              "text": "Using this rule, someone's citizenship can be inferred from facts about a person's city of residence and the nation in which that city is located."
            },
            {
              "iri": "Section-2-Paragraph-3-Sentence-4",
              "text": "In Closed rules all head variables occur in the body of the rule and all variables appear at least twice."
            },
            {
              "iri": "Section-2-Paragraph-3-Sentence-5",
              "text": "Thus, there can be no variable quantified existentially in the head of the rule."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-4-Sentence-1",
              "text": "Closed rules enable inference of specific facts that, if true, are missing from the KG."
            },
            {
              "iri": "Section-2-Paragraph-4-Sentence-2",
              "text": "They draw attention to a potential missing fact only if the fact is able to be inferred by the learnt rule."
            },
            {
              "iri": "Section-2-Paragraph-4-Sentence-3",
              "text": "KG completion in this way predicts answers for known unknowns."
            },
            {
              "iri": "Section-2-Paragraph-4-Sentence-4",
              "text": "In this paper we consider, for the first time, the problem of rule-based knowledge graph completion that guides the discovery of unknown unknowns."
            },
            {
              "iri": "Section-2-Paragraph-4-Sentence-5",
              "text": "Generally, in knowledge graph completion, a specific missing fact is predicted."
            },
            {
              "iri": "Section-2-Paragraph-4-Sentence-6",
              "text": "In contrast, we predict the existence of missing facts even when an entity involved in the missing fact may be absent from the KG."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-5-Sentence-1",
              "text": "We propose learning open path rules (OP) from which we infer open-ended questions (e.g. citizenOf(Ann, ?)) instead of facts (e.g. citizenOf(Ann, Australia))."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-2",
              "text": "Traditional knowledge graph completion is then done by answering the actively generated questions."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-3",
              "text": "The proposed OP rule formalism is a fragment of the language of existential rules which is expressive enough to adduce queries yet suitable for our scalable embedding-based rule mining system."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-4",
              "text": "OP rules provide evidence that a fact is missing even when there is evidence for only one entity of the pair, and a question is generated accordingly."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-5",
              "text": "The queries adduced from OP rules identify that a new fact is needed when the answer is not known."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-6",
              "text": "The answer might be an entity already present in the KG, or absent from it."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-7",
              "text": "In the latter case, a query could be posed to a user engaged in a curating task or to a Web question-answering engine."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-8",
              "text": "In particular, an answer to the question could introduce new entities to the KG, and by this the approach addresses a previously unstudied direction in knowledge graph completion, that is missing entities."
            },
            {
              "iri": "Section-2-Paragraph-5-Sentence-9",
              "text": "The process of OP rule learning and adducing queries from OP rules is not an alternative to link prediction; it complements traditional link prediction by providing relevant queries to link predictors and can, for the first time, make knowledge graph completion fully automatic."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-6-Sentence-1",
              "text": "For example, consider the OP rule, citizenOf(x, y) studiesIn(x, z)."
            },
            {
              "iri": "Section-2-Paragraph-6-Sentence-2",
              "text": "This rule implies that if we know an entity x studies in an institute z, then x is a citizen of somewhere (y)."
            },
            {
              "iri": "Section-2-Paragraph-6-Sentence-3",
              "text": "If the body of this rule is instantiated like studiesIn(Sam, ANU) we can infer the query citizenOf(Sam, ?)."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-7-Sentence-1",
              "text": "Our work addresses a long-standing gap in traditional link prediction systems that use the KG to propose missing facts, but need to be seeded with queries about potential missing facts."
            },
            {
              "iri": "Section-2-Paragraph-7-Sentence-2",
              "text": "Conventionally, for evaluating link predictors, these queries are trivially generated from test facts that are held out from the KG in the hope that a high-performing predictor will rediscover the held-out (and thereby missing) facts."
            },
            {
              "iri": "Section-2-Paragraph-7-Sentence-3",
              "text": "However, once a link predictor is deployed over a working KG, test facts cannot be held out, and re-discovery of held-out facts is unproductive, so whence does a query arise to drive the link predictor?"
            },
            {
              "iri": "Section-2-Paragraph-7-Sentence-4",
              "text": "We propose that the queries we derive from our OP rules can be used to generate the queries that link predictors need to repair working KGs."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-8-Sentence-1",
              "text": "Arbitrary queries are of little use; queries need to be relevant in order to be useful."
            },
            {
              "iri": "Section-2-Paragraph-8-Sentence-2",
              "text": "For example, consider the fact presidentOf(Obama, USA), held back from training data for a link predictor."
            },
            {
              "iri": "Section-2-Paragraph-8-Sentence-3",
              "text": "Conventionally, this known-missing fact is used to generate the following two relevant queries presidentOf(?, USA) and presidentOf(Obama, ?)."
            },
            {
              "iri": "Section-2-Paragraph-8-Sentence-4",
              "text": "Instead when a link predictor is asked an irrelevant query like presidentOf(Celine Dion, ?), it will try to rank a set of entities (countries) to answer this query even though no correct answer exists either inside or outside the KG."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-9-Sentence-1",
              "text": "In summary, by learning OP rules to derive queries we address the following problems in traditional knowledge graph completion:"
            },
            {
              "iri": "Section-2-Paragraph-9-Sentence-2",
              "text": "Identifying a missing fact even when there is no pattern (such as a closed rule) that fully instantiates the fact in the KG;"
            },
            {
              "iri": "Section-2-Paragraph-9-Sentence-3",
              "text": "Generating relevant queries that can serve as input to link predictors to complete the KG (which is feasible when the correct answer is an entity extant in the KG); and"
            },
            {
              "iri": "Section-2-Paragraph-9-Sentence-4",
              "text": "Generating queries that can introduce missing entities into the KG (although this requires answer sources beyond current link predictors)."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-10-Sentence-1",
              "text": "The contributions of this paper are as follows, greatly extending early explorations published in."
            },
            {
              "iri": "Section-2-Paragraph-10-Sentence-2",
              "text": "We present a novel method for learning open path rules from a KG."
            },
            {
              "iri": "Section-2-Paragraph-10-Sentence-3",
              "text": "These are existential rules with a different form to the usual closed path rules that are conventionally used for knowledge graph completion tasks."
            },
            {
              "iri": "Section-2-Paragraph-10-Sentence-4",
              "text": "We propose an algorithm, OPRL, for learning these rules, including novel fitness criteria for discarding poor rules early, and efficient vector computation of formal quality criteria."
            },
            {
              "iri": "Section-2-Paragraph-10-Sentence-5",
              "text": "We show that, together with KG sampling, our algorithm is effective over very large KGs."
            },
            {
              "iri": "Section-2-Paragraph-10-Sentence-6",
              "text": "As such, we introduce a first solution to the problem of active knowledge graph completion (AKGC), where we aim, instead of suggesting missing facts, to ask the best questions to complete a KG."
            }
          ]
        },
        {
          "iri": "Section-2-Paragraph-11",
          "sentences": [
            {
              "iri": "Section-2-Paragraph-11-Sentence-1",
              "text": "The rest of the paper is structured as follows."
            },
            {
              "iri": "Section-2-Paragraph-11-Sentence-2",
              "text": "After presenting some foundations in Section 2, we describe our target language for learning in Section 3, including the formalism of OP rules."
            },
            {
              "iri": "Section-2-Paragraph-11-Sentence-3",
              "text": "Section 4 proposes the OP rule learning method OPRL that includes a novel embedding-based heuristic function and evaluation method."
            },
            {
              "iri": "Section-2-Paragraph-11-Sentence-4",
              "text": "Section 5 presents the process for generating relevant queries derived from the learnt OP rules."
            },
            {
              "iri": "Section-2-Paragraph-11-Sentence-5",
              "text": "In Section 6 we formalise the new quality notion of query relevance and discuss the results of a range of experiments with our novel OPRL."
            },
            {
              "iri": "Section-2-Paragraph-11-Sentence-6",
              "text": "In Section 7, we present the work in the literature related to link prediction and active knowledge graph completion."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-3",
      "subtitle": "Background",
      "paragraphs": [
        {
          "iri": "Section-3-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-1-Sentence-1",
              "text": "2.1 Rule-Based KG Completion"
            },
            {
              "iri": "Section-3-Paragraph-1-Sentence-2",
              "text": "An entity e is an identifier for an object such as a place or a person, and a fact (also known as a link) is an RDF triple (e, P, e'), whereby the subject entity e is related to an object entity e' via the binary predicate (also known as a property), P."
            },
            {
              "iri": "Section-3-Paragraph-1-Sentence-3",
              "text": "Here we write facts in the form P(e, e')."
            },
            {
              "iri": "Section-3-Paragraph-1-Sentence-4",
              "text": "A knowledge graph (KG) is a pair K = (E, F) where F is a set of facts and E is the set of entities that exist in the facts F."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-2-Sentence-1",
              "text": "Rule learning systems employ a rule language to express rules."
            },
            {
              "iri": "Section-3-Paragraph-2-Sentence-2",
              "text": "RLVLR and ScaleKB use so-called closed path (CP) rules that are a kind of closed rule with no free variables."
            },
            {
              "iri": "Section-3-Paragraph-2-Sentence-3",
              "text": "Each consists of two parts, a head at the front of the implication arrow and a body at the tail."
            },
            {
              "iri": "Section-3-Paragraph-2-Sentence-4",
              "text": "The rule forms a closed path, or single unbroken loop of links between the variables."
            },
            {
              "iri": "Section-3-Paragraph-2-Sentence-5",
              "text": "It has the following general form, where P_h is the single predicate of the head, and P_1, ..., P_n (for n >= 1) are predicates of the body and x, y, z_1, ..., z_{n-1} are variables in the rule."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-3-Sentence-1",
              "text": "We interpret this kind of rule with universal quantification of all variables at the outside, and so we can infer a fact that instantiates the head of the rule by finding an instantiation of the body of the rule in the KG."
            },
            {
              "iri": "Section-3-Paragraph-3-Sentence-2",
              "text": "For example, from the rule citizenOf(x, y) \u2190 livesIn(x, z) \u2227 locatedIn(z, y), if we have the facts in the KG, livesIn(Bronte, Canberra) and locatedIn(Canberra, Australia), then we can infer and assert the following new fact in the KG, citizenOf(Bronte, Australia)."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-4-Sentence-1",
              "text": "Rules are considered more useful if they generalise well, that is, they explain many facts."
            },
            {
              "iri": "Section-3-Paragraph-4-Sentence-2",
              "text": "To quantify this idea, we recall measures support, head coverage, and standard confidence that are used in some major approaches to rule learning."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-5-Sentence-1",
              "text": "Definition 1 (satisfies, support)."
            },
            {
              "iri": "Section-3-Paragraph-5-Sentence-2",
              "text": "Let r be a CP rule of the form given earlier."
            },
            {
              "iri": "Section-3-Paragraph-5-Sentence-3",
              "text": "A pair of entities (e, e') satisfies the body of r, denoted body_r(e, e'), if there exist entities e_1, ..., e_{n-1} in the KG such that all of {P_1(e, e_1), P_2(e_1, e_2), ..., P_n(e_{n-1}, e')} are facts in the KG."
            },
            {
              "iri": "Section-3-Paragraph-5-Sentence-4",
              "text": "Further, (e, e') satisfies the head of r, denoted P_h(e, e'), if P_h(e, e') is a fact in the KG."
            },
            {
              "iri": "Section-3-Paragraph-5-Sentence-5",
              "text": "In other words, a pair of entities satisfies both the body and the head of a CP rule if the rule, instantiated by those entities, holds true in the KG."
            },
            {
              "iri": "Section-3-Paragraph-5-Sentence-6",
              "text": "Then the support of r counts the head (target) instances for which the rule body and head are both satisfied in the KG."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-6-Sentence-1",
              "text": "Definition 2 (Standard confidence (SC), head coverage (HC))."
            },
            {
              "iri": "Section-3-Paragraph-6-Sentence-2",
              "text": "SC describes how frequently the rule is true, i.e., of the ways that the body is satisfied in the KG, the proportion of the inferred head instances that are also satisfied."
            },
            {
              "iri": "Section-3-Paragraph-6-Sentence-3",
              "text": "It is closely related to confidence widely used in association rule mining."
            },
            {
              "iri": "Section-3-Paragraph-6-Sentence-4",
              "text": "On the other hand, HC measures the explanatory power of the rule, i.e., the proportion of the facts satisfying the head of the rule that can be inferred by satisfying the rule body."
            },
            {
              "iri": "Section-3-Paragraph-6-Sentence-5",
              "text": "It is closely related to coverage widely used for rule learning in inductive logic programming."
            },
            {
              "iri": "Section-3-Paragraph-6-Sentence-6",
              "text": "A rule that has both 100% HC and SC explains every fact in the KG that is an instance of its head and is redundant with respect to the KG."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-7-Sentence-1",
              "text": "Representation Learning for KG Completion"
            },
            {
              "iri": "Section-3-Paragraph-7-Sentence-2",
              "text": "Representation learning methods have been developed to model KGs for tasks such as link prediction, entity resolution, and link-based clustering."
            },
            {
              "iri": "Section-3-Paragraph-7-Sentence-3",
              "text": "The two key phases in representation learning are (1) embedding the entities and predicates of a given KG into a latent space, and (2) reconstructing the KG based on the learned embeddings to predict new facts."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-8-Sentence-1",
              "text": "The KG is embedded into a low-dimensional vector space of latent, unnamed features not present in the KG vocabulary."
            },
            {
              "iri": "Section-3-Paragraph-8-Sentence-2",
              "text": "The plausibility of a fact is defined by a scoring function over the embedded representations of its predicate and entities."
            },
            {
              "iri": "Section-3-Paragraph-8-Sentence-3",
              "text": "Learning and operating on latent representations benefits from the use of unobserved but intrinsic properties of entities and their relations."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-9-Sentence-1",
              "text": "Various methods have been proposed to construct embeddings."
            },
            {
              "iri": "Section-3-Paragraph-9-Sentence-2",
              "text": "Two main categories are translation-based embeddings and compositional embeddings."
            },
            {
              "iri": "Section-3-Paragraph-9-Sentence-3",
              "text": "The translation-based embeddings represent predicates as vectors and use an additive calculus for scoring."
            },
            {
              "iri": "Section-3-Paragraph-9-Sentence-4",
              "text": "The compositional embeddings represent predicates as weight matrices and use a product calculus for scoring."
            }
          ]
        },
        {
          "iri": "Section-3-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-3-Paragraph-10-Sentence-1",
              "text": "We use embeddings learned by RESCAL for our novel heuristic function for mining OP rules."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-2",
              "text": "RESCAL is a compositional-based embedding learner."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-3",
              "text": "It embeds each entity e_i by a vector e_i \u2208 \u211d^d and each predicate P_k by a matrix P_k \u2208 \u211d^{d\u00d7d}, where \u211d is the set of real numbers and d is an integer."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-4",
              "text": "d is a parameter to the learner specifying the dimensionality of the latent feature space."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-5",
              "text": "RESCAL learns the two sets of embeddings, vectors {e_i} and matrices {P_k}, by minimizing a loss function defined over the product of the entity and predicate embeddings."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-6",
              "text": "RESCAL captures rich interactions amongst entities and predicates because it learns a larger number of more finely-targeted weight parameters than methods which embed the predicates into vectors."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-7",
              "text": "RESCAL embeddings are also larger and simpler than those in more recent embedding-based link predictors such as HOLE and TuckER."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-8",
              "text": "The compactness of the latter embeddings is useful for link prediction but counter-productive for our purposes where we use embeddings in a heuristic function."
            },
            {
              "iri": "Section-3-Paragraph-10-Sentence-9",
              "text": "Furthermore, RESCAL has empirically demonstrated strength when used in a heuristic for mining logical axioms as we need here."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-4",
      "subtitle": "Rules with Free Variables for Active Knowledge Graph Completion",
      "paragraphs": [
        {
          "iri": "Section-4-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-1-Sentence-1",
              "text": "Unlike earlier work in rule mining for KG completion, for our active knowledge graph completion task we mine open path (OP) rules of the following form:"
            },
            {
              "iri": "Section-4-Paragraph-1-Sentence-2",
              "text": "P_t(x, z_0) \u2190 P_1(z_0, z_1) \u2227 P_2(z_1, z_2) \u2227 ... \u2227 P_n(z_{n-1}, y)."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-2-Sentence-1",
              "text": "Each P_i and P_t are predicates in the KG and each of {x, z_i, y} are variables; x and y are free while the z_i are bound."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-3-Sentence-1",
              "text": "Unlike CP rules, OP rules do not necessarily form a looping path over variables, but can have a more linear shape."
            },
            {
              "iri": "Section-4-Paragraph-3-Sentence-2",
              "text": "From an OP rule, two CP rules are logical consequences: one for each unification of free variable y with a variable of the head P_t."
            },
            {
              "iri": "Section-4-Paragraph-3-Sentence-3",
              "text": "However, the OP rule is not a consequence of any CP rule; OP rules are strictly more expressive than CP rules."
            },
            {
              "iri": "Section-4-Paragraph-3-Sentence-4",
              "text": "While every instantiation of a CP rule is also an instantiation of a corresponding OP rule, OP rules admit instantiations that cannot be instantiations of any CP rule."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-4-Sentence-1",
              "text": "From an instantiation of the body of an OP rule, we cannot infer a fact, but only a question."
            },
            {
              "iri": "Section-4-Paragraph-4-Sentence-2",
              "text": "For example, the following OP rule, citizenOf(x, t) \u2190 livesIn(x, z), states that if an entity, x, lives in z, then that entity is a citizen of somewhere (t)."
            },
            {
              "iri": "Section-4-Paragraph-4-Sentence-3",
              "text": "By instantiating the body of this rule as follows, livesIn(Bronte, Canberra), we could infer the query, citizenOf(Bronte, ?)."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-5-Sentence-1",
              "text": "To assess the quality of our mined open path rules, we introduce open path standard confidence (OPSC) and open path head coverage (OPHC) derived from the closed path forms (Definition 2)."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-6-Sentence-1",
              "text": "Definition 3 (open path: OPsupp, OPSC, OPHC)."
            },
            {
              "iri": "Section-4-Paragraph-6-Sentence-2",
              "text": "Let r be an OP rule of the form given earlier."
            },
            {
              "iri": "Section-4-Paragraph-6-Sentence-3",
              "text": "Let r, e, e', e_i, body_r, P_t be as given in Definition 1 but adapted straightforwardly to the open path rule case."
            },
            {
              "iri": "Section-4-Paragraph-6-Sentence-4",
              "text": "Then a pair of entities (e, e') satisfies the body of r, denoted body_r(e, e'), if there exist entities e_1, ..., e_{n-1} in the KG such that P_1(e, e_1), P_2(e_1, e_2), ..., P_n(e_{n-1}, e') are facts in the KG."
            },
            {
              "iri": "Section-4-Paragraph-6-Sentence-5",
              "text": "A pair (e', e) satisfies the head of r, denoted P_t(e', e), if P_t(e', e) is a fact in the KG."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-7-Sentence-1",
              "text": "The open path support, open path standard confidence, and open path head coverage of r are given respectively by the KG."
            },
            {
              "iri": "Section-4-Paragraph-7-Sentence-2",
              "text": "Then the support degree of r is defined as:"
            },
            {
              "iri": "Section-4-Paragraph-7-Sentence-3",
              "text": "OPsupp(r) = |{e : \u2203e', e' s.t. body_r(e, e') and P_t(e', e)}|."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-8-Sentence-1",
              "text": "OPSC(r) = OPsupp(r) / |{e: \u2203e' s.t. body_r(e, e')}|."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-9-Sentence-1",
              "text": "OPHC(r) = OPsupp(r) / |{e: \u2203e' s.t. P_t(e', e)}|."
            }
          ]
        },
        {
          "iri": "Section-4-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-4-Paragraph-10-Sentence-1",
              "text": "For example, consider the OP rule, P_1(x, z_0) \u2190 P_2(z_0, z_1) \u2227 P_3(z_1, y)."
            },
            {
              "iri": "Section-4-Paragraph-10-Sentence-2",
              "text": "Assume we have 3 entities ({e_3, e_4, e_5}) which can instantiate z_0 to satisfy both P_1(x, z_0) and P_2(z_0, z_1) \u2227 P_3(z_1, y)."
            },
            {
              "iri": "Section-4-Paragraph-10-Sentence-3",
              "text": "Assume the number of entities that can instantiate z_0 to satisfy the head part is 5 ({e_1, e_2, e_3, e_4, e_5}) and the number of entities that can instantiate z_0 to satisfy the body part is 7 ({e_3, e_4, e_5, e_6, e_7, e_8, e_9})."
            },
            {
              "iri": "Section-4-Paragraph-10-Sentence-4",
              "text": "Hence, we have for this rule, OPsupp = 3, OPSC = 3/7 and OPHC = 3/5."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-5",
      "subtitle": "OP Rule Learning",
      "paragraphs": [
        {
          "iri": "Section-5-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-5-Paragraph-1-Sentence-1",
              "text": "Our objective is to mine a KG for high-quality OP rules about a specific target predicate in the head, P."
            },
            {
              "iri": "Section-5-Paragraph-1-Sentence-2",
              "text": "While we adhere to the architecture of RLVLR that learns CP rules, we propose the following novelties for mining OP rules: (i) a novel fitness function which can estimate the quality of an OP rule based on the embedding representations of its predicates; and (ii) a novel vector computation which allows the system to evaluate the OP rules against a massive KG to compute quality measures, OPSC and OPHC."
            },
            {
              "iri": "Section-5-Paragraph-1-Sentence-3",
              "text": "Our OP rule miner, OPRL, is summarised in Algorithm 1."
            },
            {
              "iri": "Section-5-Paragraph-1-Sentence-4",
              "text": "It takes user parameters for the maximum length of rules and the least acceptable OPSC and OPHC scores."
            }
          ]
        },
        {
          "iri": "Section-5-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-5-Paragraph-2-Sentence-1",
              "text": "Algorithm 1: OPRL"
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-2",
              "text": "Input: a KG K, a target predicate P."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-3",
              "text": "Parameter: a max rule length l, MinOPSC and MinOPHC."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-4",
              "text": "Output: a set of OP rules R."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-5",
              "text": "K' := Sampling(K, P)."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-6",
              "text": "(P, A) := Embeddings(K')."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-7",
              "text": "R' := \u2205."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-8",
              "text": "For 2 \u2264 k \u2264 l do."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-9",
              "text": "Add PathFinding(K', P_t, P, A, k) to R'."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-10",
              "text": "End for."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-11",
              "text": "Add IncPathFinding(K', P_t, P, A, k, R') to R'."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-12",
              "text": "R := Evaluation(R', K)."
            },
            {
              "iri": "Section-5-Paragraph-2-Sentence-13",
              "text": "Return R."
            }
          ]
        },
        {
          "iri": "Section-5-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-5-Paragraph-3-Sentence-1",
              "text": "First, we reduce the KG size because existing embedding-based methods cannot handle vast KGs."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-2",
              "text": "For instance, RESCAL is unable to handle YAGO2."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-3",
              "text": "We use the sampling algorithm, Sampling(), proposed in RLVLR to build a reduced KG."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-4",
              "text": "This means that embeddings are computed only for entities that are relevant to a target predicate."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-5",
              "text": "In more detail, Sampling() computes a fragment of the KG (K') consisting of a bounded number of entities that are related to the target predicate (i.e., P_t)."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-6",
              "text": "The method initializes a set of entities by considering a number of entities which are involved in the target predicate."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-7",
              "text": "For example, if we have P_t(e1, e2) as a fact, then our set of entities includes e1 and e2."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-8",
              "text": "Then, the method extends the set of entities by adding entities that are related to the existing entities in the set via any predicates, like adding e3 if we have some P_i(e3, e1) as a fact."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-9",
              "text": "This last step iterates a number of times based on the maximum length of target rules."
            },
            {
              "iri": "Section-5-Paragraph-3-Sentence-10",
              "text": "After the set of entities is obtained, all facts (i.e., links) between these entities form the reduced KG, K'."
            }
          ]
        },
        {
          "iri": "Section-5-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-5-Paragraph-4-Sentence-1",
              "text": "We then compute embedding models to construct a fitness function to rapidly estimate a rule's quality, and so significantly improve scalability."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-2",
              "text": "Embeddings() obtains the embeddings for predicates and arguments in the sample KG."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-3",
              "text": "Existing representation learners such as RESCAL usually compute embeddings for entities and predicates."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-4",
              "text": "Instead, we use the method proposed in RLVLR, extending RESCAL, to additionally compute argument embeddings that are derived from entity embeddings."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-5",
              "text": "RESCAL embeds each entity e_j to a vector E_j \u2208 R^d and each predicate P_i to a 2D array P_i \u2208 R^(d\u00d7d) where d is an integer parameter of RESCAL and R is the set of real numbers."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-6",
              "text": "For each given fact P_1(e0, e1), the following scoring function is defined: f(e0, P1, e1) = E_0^T \u00b7 P1 \u00b7 E1."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-7",
              "text": "The scoring function specifies the plausibility of the fact that e0 is connected to e1 via predicate P1."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-8",
              "text": "After computing embeddings, in shortest-first order, we exhaustively generate OP rules for a target predicate P_i and its inverse P_i^-1 in PathFinding()."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-9",
              "text": "The inverse is defined as \u2200e, e' P_i^-1(e', e) = P_i(e, e')."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-10",
              "text": "Since the target predicate is fixed, generating an OP rule is reduced to generating a path to comprise the body, i.e., a sequence of predicates P1', P2', ..., Pn' with required OP rule variable patterns."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-11",
              "text": "We apply the proposed fitness function to each rule on generation to rapidly discard poor performers."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-12",
              "text": "In IncPathFinding(), we create additional candidate rules by extending some top-ranked candidates."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-13",
              "text": "We learn new short OP rules for the rightmost predicate using PathFinding()."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-14",
              "text": "If we find a good rule about that predicate, then we extend the original rule by appending the new body to the original tail, and we keep both the original and extended rules."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-15",
              "text": "For example, consider that PathFinding() generated the rule: P1(x, z0) \u2190 P2(z0, z1) \u2227 P3(z1, z2) \u2227 P4(z2, y)."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-16",
              "text": "In IncPathFinding(), the rule is extended to: P1(x, z0) \u2190 P2(z0, z1) \u2227 P3(z1, z2) \u2227 P4(z2, z3) \u2227 P5(z3, y) if PathFinding() also generates P4(x, z0) \u2190 P5(z0, y)."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-17",
              "text": "We then use a redundancy elimination method to make sure there is no repetition in all the mined rules and then evaluate candidate rules by OPSC and OPHC in Evaluate()."
            },
            {
              "iri": "Section-5-Paragraph-4-Sentence-18",
              "text": "We use efficient matrix and vector multiplication for evaluation, which is crucial for scalability."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-6",
      "subtitle": "OP Rule Learning: Rule Quality Estimation using Embeddings",
      "paragraphs": [
        {
          "iri": "Section-6-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-1-Sentence-1",
              "text": "Since the number of potential rules generated in PathFinding() is enormous, we rapidly filter out candidates of low quality."
            },
            {
              "iri": "Section-6-Paragraph-1-Sentence-2",
              "text": "For this purpose, the quality is estimated by either of two fitness functions: co-occurrence or open path, both of which are derived from embedding representations."
            },
            {
              "iri": "Section-6-Paragraph-1-Sentence-3",
              "text": "The former uses entity embeddings alone, while the latter incorporates predicate embeddings as well."
            },
            {
              "iri": "Section-6-Paragraph-1-Sentence-4",
              "text": "We use RESCAL to compute both."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-2-Sentence-1",
              "text": "Co-occurrence Fitness Function."
            },
            {
              "iri": "Section-6-Paragraph-2-Sentence-2",
              "text": "Each instance of an OP rule connects its head and body via a shared entity in place of z0, so an OP rule tends to have high OPsupp (and so high OPSC and OPHC) if the entities which satisfy the second argument of P_t have a large intersection with the entities that satisfy the first argument of P_t."
            },
            {
              "iri": "Section-6-Paragraph-2-Sentence-3",
              "text": "When predicate pairs associate similar entities this way, this induces a latent-feature relationship between the predicates that we call co-occurrence."
            },
            {
              "iri": "Section-6-Paragraph-2-Sentence-4",
              "text": "For instance, the two predicates liveIn(e'', e) and locatedIn(e', e') may co-occur because in both cases e is often a city."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-3-Sentence-1",
              "text": "Based on this observation, a co-occurrence fitness function for mining CP rules is defined using argument embeddings in RLVLR, and we adapt it here."
            },
            {
              "iri": "Section-6-Paragraph-3-Sentence-2",
              "text": "RLVLR also defines a similarity fitness function that is not applicable here because it relies on the head predicate to share a large number of entities with the body in both argument positions (i.e., one with the first argument of the first body predicate and the other with the last argument of the last body predicate)."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-4-Sentence-1",
              "text": "Since CP rules have no free variables, searching for good CP rules is computationally easier than for OP rules where there are many more satisfying facts."
            },
            {
              "iri": "Section-6-Paragraph-4-Sentence-2",
              "text": "In CP rules, the head and body present similar concepts so the RLVLR algorithm can use a similarity scoring function."
            },
            {
              "iri": "Section-6-Paragraph-4-Sentence-3",
              "text": "For OP rules, there is no holistic similarity between the head and body."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-5-Sentence-1",
              "text": "For example, consider the following CP rule: isCitizenOf(x,y) \u2190 isBornIn(x,z) \u2227 locatedIn(z,y), where the head and body present similar relations between the pair of entities (x,y)."
            },
            {
              "iri": "Section-6-Paragraph-5-Sentence-2",
              "text": "On the other hand, in an OP rule like citizenOf(x,t) \u2190 marriedTo(x,z) \u2227 parentOf(z,y), there is no holistic similarity, and the head relates different pairs of entities (x,t) to the pairs connected via the body of the same rule (x,y), so we cannot expect the pairs to be similar."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-6-Sentence-1",
              "text": "For argument embeddings, each predicate has a subject argument in the first position and an object argument in the second position."
            },
            {
              "iri": "Section-6-Paragraph-6-Sentence-2",
              "text": "Each argument's embedding is a vector obtained by averaging the embeddings of all the entities in the argument position."
            },
            {
              "iri": "Section-6-Paragraph-6-Sentence-3",
              "text": "For entity e, we write its embedding vector as e."
            },
            {
              "iri": "Section-6-Paragraph-6-Sentence-4",
              "text": "For predicate P, we write its embedding matrix as P, also called a weight matrix."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-7-Sentence-1",
              "text": "Definition 4 (argument embedding). Let K = (E, F) be a KG."
            },
            {
              "iri": "Section-6-Paragraph-7-Sentence-2",
              "text": "The argument embeddings of the subject and object arguments of a predicate P are vectors defined respectively as:"
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-8-Sentence-1",
              "text": "P(1) = (1/n) \u2211 s_e * e for e in S_p, and P(2) = (1/n) \u2211 o_e * e for e in O_p."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-9-Sentence-1",
              "text": "Here, n is the number of facts in the KG."
            },
            {
              "iri": "Section-6-Paragraph-9-Sentence-2",
              "text": "S_p and O_p are the sets of entities occurring as subjects and objects of P, respectively."
            },
            {
              "iri": "Section-6-Paragraph-9-Sentence-3",
              "text": "More precisely, S_p = {e | \u2203e' such that P(e, e') \u2208 F} and O_p = {e' | \u2203e such that P(e, e') \u2208 F}."
            },
            {
              "iri": "Section-6-Paragraph-9-Sentence-4",
              "text": "The terms s_e and o_e represent the number of times an entity e occurs as a subject and an object of P in K respectively."
            },
            {
              "iri": "Section-6-Paragraph-9-Sentence-5",
              "text": "More precisely, s_e = |{e' such that P(e, e') \u2208 F}| and o_e = |{e' such that P(e', e) \u2208 F}|."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-10-Sentence-1",
              "text": "Now the co-occurrence fitness function for CP rules used in RLVLR is modified for the OP case."
            },
            {
              "iri": "Section-6-Paragraph-10-Sentence-2",
              "text": "In an OP rule of the form (2), the co-occurrences of z_0 as the object argument of P_t and subject argument of P_1, and z_i (1 \u2264 i \u2264 n - 1) as the object argument of P_i and subject argument of P_{i+1}, motivates us to highly value rules with the properties:"
            },
            {
              "iri": "Section-6-Paragraph-10-Sentence-3",
              "text": "P(2)_t \u2248 P(1)_1, and P(2)_i \u2248 P(1)_{i+1} (1 \u2264 i \u2264 n - 1)."
            },
            {
              "iri": "Section-6-Paragraph-10-Sentence-4",
              "text": "Pairwise local fitness functions are defined accordingly."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-11",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-11-Sentence-1",
              "text": "Definition 5 (local co-occurrence fitness). Let r be an OP rule of the form (2)."
            },
            {
              "iri": "Section-6-Paragraph-11-Sentence-2",
              "text": "Then:"
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-12",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-12-Sentence-1",
              "text": "f^0_loc (P_t, P_1) = sim(P(2)_t , P(1)_1)"
            },
            {
              "iri": "Section-6-Paragraph-12-Sentence-2",
              "text": "f^i_loc (P_i, P_{i+1}) = sim(P(2)_i , P(1)_{i+1}) for 1 \u2264 i \u2264 n - 1."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-13",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-13-Sentence-1",
              "text": "The similarity function sim is defined by the Frobenius norm, i.e., for two matrices M_1 and M_2:"
            },
            {
              "iri": "Section-6-Paragraph-13-Sentence-2",
              "text": "sim(M_1, M_2) = exp(-||M_1 - M_2||_F)."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-14",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-14-Sentence-1",
              "text": "Co-occurrence for the whole rule can then be obtained by aggregating the pairwise local occurrences as follows."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-15",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-15-Sentence-1",
              "text": "Definition 6 (co-occurrence fitness). Let r be an open path rule of the form (2)."
            },
            {
              "iri": "Section-6-Paragraph-15-Sentence-2",
              "text": "Then:"
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-16",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-16-Sentence-1",
              "text": "f_coo (r) = f^0_loc (P_t, P_1) + \u2211_{i=1}^{n-1} f^i_loc (P_i, P_{i+1})."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-17",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-17-Sentence-1",
              "text": "By using argument embeddings built from entity embeddings, the co-occurrence captures the weight of connections of sequential entities along the path."
            },
            {
              "iri": "Section-6-Paragraph-17-Sentence-2",
              "text": "Next, we introduce an alternative quality estimation function that uses both entity and predicate embeddings, called open path fitness, f_op (.)."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-18",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-18-Sentence-1",
              "text": "4.1.2. Open Path Fitness Function"
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-2",
              "text": "An OP rule acts to connect entities satisfying the subject argument of the head predicate, P_t, to entities forming the object argument of the tail predicate, P_n, along a path of entities that satisfy a chain of predicates in the rule."
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-3",
              "text": "The product of the predicate embeddings along the path acts as a low-dimensional representation of the latent features of a path that connects its endpoints, and therefore represents the overall rule from the perspective of the predicates."
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-4",
              "text": "However, to anchor the rule, we also need to account for the entities that satisfy the free variables at the endpoints, as does the RESCAL evaluation function for a single predicate."
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-5",
              "text": "Conveniently, our argument embeddings for the subject argument of P_t and the object argument of P_n give us what we need by averaging the embeddings of all the entities at the endpoints."
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-6",
              "text": "Based on this observation, we propose the open path fitness function to estimate the rule quality."
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-7",
              "text": "Definition 7 (open path fitness)."
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-8",
              "text": "Let r be an OP rule of the form (2)."
            },
            {
              "iri": "Section-6-Paragraph-18-Sentence-9",
              "text": "Then the open path fitness for r is defined by the product:"
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-19",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-19-Sentence-1",
              "text": "f_op (r) = P(1)^T P_t P_1 P_2 ... P_n P(2)_n."
            }
          ]
        },
        {
          "iri": "Section-6-Paragraph-20",
          "sentences": [
            {
              "iri": "Section-6-Paragraph-20-Sentence-1",
              "text": "There is no clear reason to prefer either of the fitness functions, f_op(.) or f_coo(.), over the other, although the first focuses on entities and the second on predicates."
            },
            {
              "iri": "Section-6-Paragraph-20-Sentence-2",
              "text": "Experimentally, we find that they complement each other, and that a hybrid approach is preferable (see Table 3)."
            },
            {
              "iri": "Section-6-Paragraph-20-Sentence-3",
              "text": "In the hybrid setting, we use both fitness functions to pick the top candidate rules."
            },
            {
              "iri": "Section-6-Paragraph-20-Sentence-4",
              "text": "Hence, for each fitness function, based on fitness values of rules, we pick up only the top t% of rules, where t% is a learning system parameter that is going to be tuned."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-7",
      "subtitle": "OP Rule Learning: Evaluating Potential Rules through Matrices and Vectors",
      "paragraphs": [
        {
          "iri": "Section-7-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-1-Sentence-1",
              "text": "Now we are ready to explain the evaluation method, Evaluation() in Algorithm 1."
            },
            {
              "iri": "Section-7-Paragraph-1-Sentence-2",
              "text": "We assess the candidate rules based on the sampled KG first for efficiency, then pick the rules with OPsupp(r) \u2265 1."
            },
            {
              "iri": "Section-7-Paragraph-1-Sentence-3",
              "text": "These rules also may include a significant number of obsolete and low-quality rules, so we perform a second collection based on the two metrics, OPSC and OPHC, assessed over the whole KG."
            },
            {
              "iri": "Section-7-Paragraph-1-Sentence-4",
              "text": "We show in the following how to efficiently compute the measures using an adjacency matrix representation of the KG."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-2-Sentence-1",
              "text": "To compute OPSC and OPHC, a method is required to check the satisfiability of body atoms of all candidate rules."
            },
            {
              "iri": "Section-7-Paragraph-2-Sentence-2",
              "text": "In other words, we need to find all KG facts that can trigger a candidate rule."
            },
            {
              "iri": "Section-7-Paragraph-2-Sentence-3",
              "text": "Let KG, K = (E,F) with E= {e1,...,en} be the set of all entities and P = {P1,...,Pm} be the set of all predicates in F."
            },
            {
              "iri": "Section-7-Paragraph-2-Sentence-4",
              "text": "Like RESCAL, we represent K as a set of square n \u00d7 n adjacency matrices by defining the function A."
            },
            {
              "iri": "Section-7-Paragraph-2-Sentence-5",
              "text": "Specifically, the (i, j)th element A(Pk)[i,j] = 1 if the fact Pk(ei, ej) is in F; and 0 otherwise."
            },
            {
              "iri": "Section-7-Paragraph-2-Sentence-6",
              "text": "Thus, A(Pk) is a matrix of binary values and the set {A(Pk) : k \u2208 {1,...,m}} represents K."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-3-Sentence-1",
              "text": "We illustrate the method for computing OPSC and OPHC through an example."
            },
            {
              "iri": "Section-7-Paragraph-3-Sentence-2",
              "text": "Consider the OP rule: r: P1(x,z0) \u2190 P2(z0,z1) \u2227 P3(z1,y) and KG."
            },
            {
              "iri": "Section-7-Paragraph-3-Sentence-3",
              "text": "E = {e1,e2,e3} and F = {P1(e1,e2), P1(e2,e1), P1(e2,e3), P1(e3,e1), P2(e1, e2), P2(e3, e2), P2(e3, e3), P1(e1, e3)}."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-4-Sentence-1",
              "text": "For OPSC and OPHC, we need to calculate:"
            },
            {
              "iri": "Section-7-Paragraph-4-Sentence-2",
              "text": "(1) The number of entities that satisfy the head of the rule in the second argument position."
            },
            {
              "iri": "Section-7-Paragraph-4-Sentence-3",
              "text": "(2) The number of entities that satisfy the body of a rule in the first argument position."
            },
            {
              "iri": "Section-7-Paragraph-4-Sentence-4",
              "text": "(3) The number of entities that join the head of a rule to its body."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-5-Sentence-1",
              "text": "For (1), to find distinct entities, we sum each column of the adjacency matrix and transpose to obtain the vector v(2)(P1)."
            },
            {
              "iri": "Section-7-Paragraph-5-Sentence-2",
              "text": "Each non-zero element of this vector indicates a satisfying entity, and the number of distinct entities is given by counting the number of non-zero elements in it."
            },
            {
              "iri": "Section-7-Paragraph-5-Sentence-3",
              "text": "Formally, the satisfying entities are {ei : \u2211j A(P1)[i,j] > 0 and 1 \u2264 j \u2264 n}, and the cardinality is the number we need."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-6-Sentence-1",
              "text": "For (2), the pairs (e, e') satisfying the body are connected by the path P1, P2, ..., Pm."
            },
            {
              "iri": "Section-7-Paragraph-6-Sentence-2",
              "text": "This can be obtained directly from the matrix product B = A(P1) A(P2) ... A(Pm), with elements having a non-zero value."
            },
            {
              "iri": "Section-7-Paragraph-6-Sentence-3",
              "text": "To find distinct entities, we sum each row corresponding to each value for the first argument to obtain the vector v(1)(B)."
            },
            {
              "iri": "Section-7-Paragraph-6-Sentence-4",
              "text": "Each non-zero element of this vector indicates a satisfying entity, and the number of distinct entities is given by counting the number of non-zero elements in v(1)(B)."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-7-Sentence-1",
              "text": "For the example, we have:"
            },
            {
              "iri": "Section-7-Paragraph-7-Sentence-2",
              "text": "B = A(P1) A(P2) = | 0 0 2 | | 0 2 1 | | 1 0 0 |."
            },
            {
              "iri": "Section-7-Paragraph-7-Sentence-3",
              "text": "v(1)(B) = | 0 | | 3 | | 1 |."
            },
            {
              "iri": "Section-7-Paragraph-7-Sentence-4",
              "text": "With satisfying entities e2 and e3 and a count of 2."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-8-Sentence-1",
              "text": "Computing (3) is now straightforward."
            },
            {
              "iri": "Section-7-Paragraph-8-Sentence-2",
              "text": "We have that the row index of non-zero elements of v(2)(P1) indicate entities that satisfy the second argument of the head."
            },
            {
              "iri": "Section-7-Paragraph-8-Sentence-3",
              "text": "Similarly, the row index of non-zero elements of v(1)(B) indicate entities that satisfy the first argument of the body."
            },
            {
              "iri": "Section-7-Paragraph-8-Sentence-4",
              "text": "Therefore, we can find the entities that satisfy both of these conditions by pairwise multiplication."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-9-Sentence-1",
              "text": "The entities we need are {ei : (v(2)(P1)[i] \u00d7 v(1)(A(P1) A(P2) ... A(Pm))[i]) > 0 and 1 \u2264 i \u2264 n}."
            },
            {
              "iri": "Section-7-Paragraph-9-Sentence-2",
              "text": "The count is the cardinality of this set."
            },
            {
              "iri": "Section-7-Paragraph-9-Sentence-3",
              "text": "For the example, we have only e3 in the set with a count of 1."
            },
            {
              "iri": "Section-7-Paragraph-9-Sentence-4",
              "text": "Hence, OPsupp(r) = 1."
            },
            {
              "iri": "Section-7-Paragraph-9-Sentence-5",
              "text": "From (1) and (2), we can easily obtain OPHC(r) = 1/1 and OPSC(r) = 1/2."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-10-Sentence-1",
              "text": "Minimum thresholds for OPSC and OPHC are supplied to Algorithm 1 at runtime, and Evaluation() discards failing rules."
            },
            {
              "iri": "Section-7-Paragraph-10-Sentence-2",
              "text": "The remaining rules are the final result of the algorithm."
            }
          ]
        },
        {
          "iri": "Section-7-Paragraph-11",
          "sentences": [
            {
              "iri": "Section-7-Paragraph-11-Sentence-1",
              "text": "In summary, we introduce the following novel components to mine OP rules from KGs:"
            },
            {
              "iri": "Section-7-Paragraph-11-Sentence-2",
              "text": "1. Proposing OP rules: We propose a fragment of function-free Horn rules that allows us to mine rules with free variables while keeping the complexity of the learning phase manageable."
            },
            {
              "iri": "Section-7-Paragraph-11-Sentence-3",
              "text": "2. Learning OP rules based on an embedding representation: We introduce a novel method to rapidly estimate the quality of each candidate rule for early pruning, based on its embedding representation."
            },
            {
              "iri": "Section-7-Paragraph-11-Sentence-4",
              "text": "3. Evaluating OP rules: We propose an efficient method to exactly compute the quality of each rule by matrix and vector operations."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-8",
      "subtitle": "Generating relevant queries for Active Knowledge Graph Completion",
      "paragraphs": [
        {
          "iri": "Section-8-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-1-Sentence-1",
              "text": "As discussed, we can now mine OP rules with measurable qualities from KGs."
            },
            {
              "iri": "Section-8-Paragraph-1-Sentence-2",
              "text": "In this section, we show how the mined rules can be used for AKGC."
            },
            {
              "iri": "Section-8-Paragraph-1-Sentence-3",
              "text": "We use OP rules to generate relevant questions which can be posed to an oracle or a human expert, just as for other active learning settings."
            },
            {
              "iri": "Section-8-Paragraph-1-Sentence-4",
              "text": "In our case, an automated link predictor makes a convenient oracle."
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-2-Sentence-1",
              "text": "Given predicate P, the AKGC task is to generate queries of the form P(?, e') and P(e, ?) for entities e and e' occurring in the KG."
            },
            {
              "iri": "Section-8-Paragraph-2-Sentence-2",
              "text": "To find relevant queries, we implement an inference module that derives queries from KG facts together with OP rules found by Algorithm 1."
            },
            {
              "iri": "Section-8-Paragraph-2-Sentence-3",
              "text": "We first use OPRL to learn OP rules about P in the head and then use the rules to induce queries of the form P(?, e') and P(e, ?)."
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-3-Sentence-1",
              "text": "For an OP rule of the form (2), if an instance of the rule body such as P_1(e, e_1), P_2(e_1, e_2), ..., P_n(e_{n-1}, e') exists in the KG, then the existence of an instance of the head with one free variable, viz the query P_t(?, e), can be induced with a quantifiable confidence."
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-4-Sentence-1",
              "text": "We define the confidence degree (CD) of such a query to be the maximum OPSC of all the rules inducing the query, thereby giving no weight to redundant rules that induce the same query."
            },
            {
              "iri": "Section-8-Paragraph-4-Sentence-2",
              "text": "Formally, the CD of q is defined as follows for a query q = P(?, e') or q = P(e, ?) and the collection of rules R that can induce q from the given KG:"
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-5-Sentence-1",
              "text": "CD(q) = max(OPSC(r))"
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-6-Sentence-1",
              "text": "In this way, we go beyond link prediction to infer relevant queries for missing links, that is, Active KGC."
            },
            {
              "iri": "Section-8-Paragraph-6-Sentence-2",
              "text": "Conventionally, a link predictor is given a query derived from the hold-out test data to predict facts, and then uses the test data to evaluate its prediction performance."
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-7-Sentence-1",
              "text": "This begs the question, whence does the query arise in an industrial application of a link prediction model?"
            },
            {
              "iri": "Section-8-Paragraph-7-Sentence-2",
              "text": "You have a KG and a high-performing link-predicting model built for the KG, but do you continue to hold out facts from your KG in order to generate queries that predict those same facts: facts that are missing only because you need them to generate queries?"
            },
            {
              "iri": "Section-8-Paragraph-7-Sentence-3",
              "text": "Or do you instead generate every possible query with no indication of comparative value to the KG?"
            },
            {
              "iri": "Section-8-Paragraph-7-Sentence-4",
              "text": "Or do you generate queries with a preference given to those with a higher probability in the KG?"
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-8-Sentence-1",
              "text": "For AKGC, we need only a named predicate (or all predicates) and use OP rules mined over training data to induce the most relevant queries over the full KB."
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-9-Sentence-1",
              "text": "For example, assume we have the following facts about the target predicate, P_1 in the test data:"
            },
            {
              "iri": "Section-8-Paragraph-9-Sentence-2",
              "text": "{P_1(e_1, e_2), P_1(e_1, e_3), P_1(e_4, e_5), P_1(e_8, e_7), P_1(e_9, e_7)}."
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-10-Sentence-1",
              "text": "Possible queries about this set of facts are: {P_1(e_1, ?), P_1(?, e_2), P_1(?, e_3), P_1(e_4, ?), P_1(?, e_5), P_1(e_8, ?), P_1(e_9, ?), P_1(?, e_7)}."
            }
          ]
        },
        {
          "iri": "Section-8-Paragraph-11",
          "sentences": [
            {
              "iri": "Section-8-Paragraph-11-Sentence-1",
              "text": "While link predictors try to answer this set of queries, in our AGKGC we mine OP rules to predict the queries themselves."
            },
            {
              "iri": "Section-8-Paragraph-11-Sentence-2",
              "text": "The number of induced queries is upper-bounded by twice the number of facts since different facts (P_1(e_8, e_7) and P_1(e_9, e_7)) can derive the same query (P_1(?, e_7))."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-9",
      "subtitle": "Experiments",
      "paragraphs": [
        {
          "iri": "Section-9-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-1-Sentence-1",
              "text": "We conducted two sets of experiments to evaluate OPRL."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-2-Sentence-1",
              "text": "Knowledge graph completion approaches are usually evaluated by link prediction, for which relevant questions are provided by human experimenters."
            },
            {
              "iri": "Section-9-Paragraph-2-Sentence-2",
              "text": "The link predictors answer each query with a sequence of ranked entities."
            },
            {
              "iri": "Section-9-Paragraph-2-Sentence-3",
              "text": "In this paper, we are concerned with asking relevant questions rather than answering such questions."
            },
            {
              "iri": "Section-9-Paragraph-2-Sentence-4",
              "text": "Our generated queries can be used in combination with a link predictor to infer new facts, but we do not use any specific link predictor to answer our questions in this paper."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-3-Sentence-1",
              "text": "This is because link predictors vary in performance and are not designed to answer a query with one correct answer, but instead a ranked sequence of answers where the top-ranked alone is not considered significant."
            },
            {
              "iri": "Section-9-Paragraph-3-Sentence-2",
              "text": "To evaluate our system, we assume a perfect link predictor that can answer any question with a correct answer when such an answer exists."
            },
            {
              "iri": "Section-9-Paragraph-3-Sentence-3",
              "text": "By this, the problem of knowledge graph completion is reduced to the problem of finding relevant questions."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-4-Sentence-1",
              "text": "We can evaluate the relevancy of a question based on the test facts."
            },
            {
              "iri": "Section-9-Paragraph-4-Sentence-2",
              "text": "If we have the answer to a question in the test set, it means the question is relevant because it uncovers some missing fact, and if we have a perfect link predictor, the question can be fed to it, and the missing fact can be retrieved."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-5-Sentence-1",
              "text": "Since our proposed system is the first method to learn rules to generate relevant questions automatically, we have no benchmark solution with which to compare."
            },
            {
              "iri": "Section-9-Paragraph-5-Sentence-2",
              "text": "We construct two baselines with which to compare: a probabilistic-based query generator and a rule-based link predictor whose output is modified to produce questions."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-6-Sentence-1",
              "text": "In our experiments, we demonstrate:"
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-7-Sentence-1",
              "text": "1. OPRL can mine quality OP rules from a range of KGs."
            },
            {
              "iri": "Section-9-Paragraph-7-Sentence-2",
              "text": "OPRL can mine massive KGs in a reasonable time."
            },
            {
              "iri": "Section-9-Paragraph-7-Sentence-3",
              "text": "Our novel hybrid fitness function outperforms the fitness function adapted from RLVLR."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-8-Sentence-1",
              "text": "2. Queries generated from OPRL's rules are relevant with good recall and precision in multiple KGs."
            },
            {
              "iri": "Section-9-Paragraph-8-Sentence-2",
              "text": "They far outperform a probabilistic baseline."
            },
            {
              "iri": "Section-9-Paragraph-8-Sentence-3",
              "text": "They also outperform queries generated by a modified leading-edge link predictor."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-9-Sentence-1",
              "text": "We conducted experiments over the four benchmark datasets given in Table 1."
            },
            {
              "iri": "Section-9-Paragraph-9-Sentence-2",
              "text": "FB15K SELECTED (which we call FB15KSE) is derived from Freebase and is widely adopted for link prediction."
            },
            {
              "iri": "Section-9-Paragraph-9-Sentence-3",
              "text": "YAGO2 core is often used for rule mining."
            },
            {
              "iri": "Section-9-Paragraph-9-Sentence-4",
              "text": "Wikidata is a multilingual, collaboratively-created KG to manage the factual information of a popular online encyclopedia."
            },
            {
              "iri": "Section-9-Paragraph-9-Sentence-5",
              "text": "We use a copy dated December 2014 provided in AMIE+."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-10-Sentence-1",
              "text": "Poker is a synthetic dataset adapted by the authors from the classic version to be a correct and complete KG for experiments."
            },
            {
              "iri": "Section-9-Paragraph-10-Sentence-2",
              "text": "Each poker hand consists of 5 playing cards drawn from a reduced deck with 6 ranks and 2 suits."
            },
            {
              "iri": "Section-9-Paragraph-10-Sentence-3",
              "text": "Each card is described using two attributes (suit and rank), for a total of 10 predictive attributes."
            },
            {
              "iri": "Section-9-Paragraph-10-Sentence-4",
              "text": "There is one Class attribute that describes the 'Poker Hand'."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-11",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-11-Sentence-1",
              "text": "All experiments were conducted on an Intel Xeon CPU E5-4620v2 @ 2.60 GHz, 66 GB RAM, and running CentOS 7."
            },
            {
              "iri": "Section-9-Paragraph-11-Sentence-2",
              "text": "For sampling, we use similar parameters to those proposed in RLVLR."
            },
            {
              "iri": "Section-9-Paragraph-11-Sentence-3",
              "text": "We set the maximum size of each sample to 800 entities."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-12",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-12-Sentence-1",
              "text": "We use RESCAL to generate embeddings with the vector size set to 100."
            },
            {
              "iri": "Section-9-Paragraph-12-Sentence-2",
              "text": "We retain the top 10% of the OP rules according to the fitness function."
            },
            {
              "iri": "Section-9-Paragraph-12-Sentence-3",
              "text": "The number of possible rules grows significantly with increasing length, as does the runtime for mining."
            }
          ]
        },
        {
          "iri": "Section-9-Paragraph-13",
          "sentences": [
            {
              "iri": "Section-9-Paragraph-13-Sentence-1",
              "text": "We use a maximum rule length of 4 for PathFinding() and we allow the extension to 6 by IncPathFinding()."
            },
            {
              "iri": "Section-9-Paragraph-13-Sentence-2",
              "text": "These parameters are the optimum obtained by tuning."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-10",
      "subtitle": "Experiments: OP Rule Learning",
      "paragraphs": [
        {
          "iri": "Section-10-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-1-Sentence-1",
              "text": "First, we assess how well OPRL finds high quality rules."
            },
            {
              "iri": "Section-10-Paragraph-1-Sentence-2",
              "text": "We are not aware of other OP rule learners with which to compare, but we do compare the performance of fitness functions proposed for OPRL."
            },
            {
              "iri": "Section-10-Paragraph-1-Sentence-3",
              "text": "The quality of rules is reported based on their OPSC/OPHC scores calculated against the full benchmark KGs, not only the samples."
            }
          ]
        },
        {
          "iri": "Section-10-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-2-Sentence-1",
              "text": "Later, we will use the mined rules for generating queries, so we need some hold-out facts for query evaluation."
            },
            {
              "iri": "Section-10-Paragraph-2-Sentence-2",
              "text": "For FB15KSE, test and training sets are available."
            },
            {
              "iri": "Section-10-Paragraph-2-Sentence-3",
              "text": "For Poker and YAGO2 core, we can find no previously prepared data, so we randomly partition 90% for training and 10% for testing."
            }
          ]
        },
        {
          "iri": "Section-10-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-3-Sentence-1",
              "text": "Table 2 shows the average numbers of quality rules mined for all predicates in the respective KGs."
            },
            {
              "iri": "Section-10-Paragraph-3-Sentence-2",
              "text": "Wikidata is an exception: only 50 randomly selected predicates are targeted."
            },
            {
              "iri": "Section-10-Paragraph-3-Sentence-3",
              "text": "Table 2 shows run times in hours, averaged over the targets."
            },
            {
              "iri": "Section-10-Paragraph-3-Sentence-4",
              "text": "Similarly, only rules with quality OPSC > 0.1 and OPHC > 0.01 are included."
            },
            {
              "iri": "Section-10-Paragraph-3-Sentence-5",
              "text": "The average number of accurate rules, i.e., the rules with OPSC > 0.8, are given as #Arules."
            }
          ]
        },
        {
          "iri": "Section-10-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-4-Sentence-1",
              "text": "Figure 1 shows the distribution of mined rules by OPSC and length."
            },
            {
              "iri": "Section-10-Paragraph-4-Sentence-2",
              "text": "We can see that OPRL can learn plausible rules over popular benchmark KGs of over eight million facts and four million entities in less than two hours."
            }
          ]
        },
        {
          "iri": "Section-10-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-5-Sentence-1",
              "text": "For illustration, we present the following two OP rules which are mined from Wikidata, with their OPSC and OPHC values respectively."
            },
            {
              "iri": "Section-10-Paragraph-5-Sentence-2",
              "text": "The first rule states that if the spouse of a person (z) is known, it is likely that the place of birth of that person is also known."
            },
            {
              "iri": "Section-10-Paragraph-5-Sentence-3",
              "text": "Thus, if the body of each rule is instantiated but there is no fact to fully instantiate the head of the rule, a relevant query is induced."
            }
          ]
        },
        {
          "iri": "Section-10-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-6-Sentence-1",
              "text": "The second rule states that if there is a region (z) in a country (w) that is known to the KG and the continent of that country (y) is also known, it is likely that the region\u2019s highest point (x) is known."
            },
            {
              "iri": "Section-10-Paragraph-6-Sentence-2",
              "text": "The third rule states that if there is a TV program (z) that has a participant (w) that has an occupation (y), then it is likely that the presenter of the program (x) is known."
            }
          ]
        },
        {
          "iri": "Section-10-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-7-Sentence-1",
              "text": "0.50, 0.02 placeOfBirth(z, x) \u2190 spouse(z, y)."
            },
            {
              "iri": "Section-10-Paragraph-7-Sentence-2",
              "text": "0.19, 0.45 highestPoint(z, x) \u2190 country\u207b\u00b9(z, w) \u2227 continent(w, y)."
            },
            {
              "iri": "Section-10-Paragraph-7-Sentence-3",
              "text": "0.59, 0.15 presenter(z, x) \u2190 participant(z, w) \u2227 occupation(w, y)."
            }
          ]
        },
        {
          "iri": "Section-10-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-10-Paragraph-8-Sentence-1",
              "text": "We conducted an experiment to assess the utility of our fitness functions, using random.org to select 20 random predicates from FB15KSE."
            },
            {
              "iri": "Section-10-Paragraph-8-Sentence-2",
              "text": "The results summarized in Table 3 show that a hybrid fitness function that combines both f_co(.) and f_op(.) is capable of mining more quality rules than either of these functions individually."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-11",
      "subtitle": "Experiments: Query Generation for Active Knowledge Graph Completion",
      "paragraphs": [
        {
          "iri": "Section-11-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-1-Sentence-1",
              "text": "Our second set of experiments assesses the relevance of queries induced from OPRL-mined rules."
            },
            {
              "iri": "Section-11-Paragraph-1-Sentence-2",
              "text": "For this purpose, we consider that a query with an answer present in the test set is a relevant query, having previously filtered out queries that can be answered from the training set."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-2-Sentence-1",
              "text": "In the absence of any comparative system for query generation, we developed three baseline query sets of the same cardinality as those generated from OPRL, called Prand."
            },
            {
              "iri": "Section-11-Paragraph-2-Sentence-2",
              "text": "Prand queries are generated by first selecting a bag of predicates, with each selected randomly with probability of its proportion in the test set."
            },
            {
              "iri": "Section-11-Paragraph-2-Sentence-3",
              "text": "Then, for half of the instances of each predicate, a subject (respectively object) entity is assigned by random selection of an entity with probability of its proportion as a subject (respectively object) of any predicate in the test set."
            },
            {
              "iri": "Section-11-Paragraph-2-Sentence-4",
              "text": "The object (respectively subject) position is free (denoted '?')."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-3-Sentence-1",
              "text": "We assess relevance over three KGs but not Wikidata because there are no public test and train sets, and the baseline query generator Prand cannot handle the massive size."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-4-Sentence-1",
              "text": "Table 4 shows average precision, recall, and F1, where a query is counted as true if it has an instance fact in the test data and false otherwise."
            },
            {
              "iri": "Section-11-Paragraph-4-Sentence-2",
              "text": "The queries were induced by OPRL rules learned over the training data with quality thresholds OPSC > 0.8 and OPHC > 0.01."
            },
            {
              "iri": "Section-11-Paragraph-4-Sentence-3",
              "text": "We see that OPRL's performance exceeds Prand on FB15KSE, YAGO2 core, and Poker by factors of approximately 6, 2, and 9, respectively."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-5-Sentence-1",
              "text": "We suspect that YAGO2 induces fewer rules and has much weaker performance because it has significantly fewer repeatable patterns."
            },
            {
              "iri": "Section-11-Paragraph-5-Sentence-2",
              "text": "This could be because it is quite correctly weakly structured or because it has significantly more missing facts."
            },
            {
              "iri": "Section-11-Paragraph-5-Sentence-3",
              "text": "If the latter, then the validity of our test set is questionable because genuinely missing facts will be treated as false instead of true, thereby incorrectly punishing precision and recall."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-6",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-6-Sentence-1",
              "text": "Supporting this explanation, we see that for synthetic Poker, which is naturally highly structured, and where all the missing facts are present in the test set, we have very close to 100% precision and excellent recall."
            },
            {
              "iri": "Section-11-Paragraph-6-Sentence-2",
              "text": "Very high precision means our queries are highly relevant as they ask questions for which the answer facts are missing from the training set."
            },
            {
              "iri": "Section-11-Paragraph-6-Sentence-3",
              "text": "Still, even for Poker, recall shows that there are relevant queries that were not generated, possibly due to the limitations of our OP language or to useful rules being discarded by the fitting function or the OPSC/OPHC thresholds."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-7",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-7-Sentence-1",
              "text": "Next, we consider the sensitivity of the performance of OPRL queries to the OPSC threshold by varying it from 0.1 to 1, learning the previously selected predicates for FB15KSE (Table 3)."
            },
            {
              "iri": "Section-11-Paragraph-7-Sentence-2",
              "text": "In Figure 2, we see that increasing OPSC has the expected behavior of decreasing recall as poorer rules get through, and increasing precision as more missing facts are found."
            },
            {
              "iri": "Section-11-Paragraph-7-Sentence-3",
              "text": "Observing a sharp anomaly where the OPSC threshold is 0.9, we suspect it might be caused by the incompleteness of FB15KSE (i.e., the generated queries may be valid but there is no answer in the test set)."
            },
            {
              "iri": "Section-11-Paragraph-7-Sentence-4",
              "text": "We repeated the experiment on the complete Poker KG and the anomaly is indeed absent as expected."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-8",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-8-Sentence-1",
              "text": "Finally, we compare OPRL queries with the state-of-the-art rule-based link predictor, RLvLR."
            },
            {
              "iri": "Section-11-Paragraph-8-Sentence-2",
              "text": "Rule learners predict facts, not queries, so we cannot compare them directly."
            },
            {
              "iri": "Section-11-Paragraph-8-Sentence-3",
              "text": "Instead, we translate each fact generated by RLvLR to two queries, by freeing the subject and object entities respectively."
            },
            {
              "iri": "Section-11-Paragraph-8-Sentence-4",
              "text": "However, while generating facts, RLvLR uses a Noisy-OR operator to aggregate high-performing rules about a target predicate."
            },
            {
              "iri": "Section-11-Paragraph-8-Sentence-5",
              "text": "This aggregation is not compatible with the query generation task where only the top prediction matters."
            },
            {
              "iri": "Section-11-Paragraph-8-Sentence-6",
              "text": "Consequently, experiments show that RLvLR with Noisy-OR performs very poorly for query generation."
            },
            {
              "iri": "Section-11-Paragraph-8-Sentence-7",
              "text": "To more fairly compare, we changed the aggregation in RLvLR to use a Max operator instead of Noisy-OR and call this RLvLR*."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-9",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-9-Sentence-1",
              "text": "We used 20 randomly selected predicates from FB15KSE in the query generation task."
            },
            {
              "iri": "Section-11-Paragraph-9-Sentence-2",
              "text": "Since RLvLR* and OPRL use the very similar minimum SC and minimum OPSC respectively, we use a ROC (Receiver Operating Characteristic) curve to compare the outputs of the two systems."
            },
            {
              "iri": "Section-11-Paragraph-9-Sentence-3",
              "text": "We plot the query performance of OPRL and RLvLR* as ROC curves in Figure 3 using minimum OPSC and minimum SC parameters as the ordering criteria."
            }
          ]
        },
        {
          "iri": "Section-11-Paragraph-10",
          "sentences": [
            {
              "iri": "Section-11-Paragraph-10-Sentence-1",
              "text": "For OPRL, we vary the minimum OPSC from 1 to 0.5 in 4 decrements and get a False Positive Rate of almost 50%."
            },
            {
              "iri": "Section-11-Paragraph-10-Sentence-2",
              "text": "For RLvLR*, we vary SC from 1 to 0.1 (the minimum and default) in 4 decrements to achieve the same False Positive Rate."
            },
            {
              "iri": "Section-11-Paragraph-10-Sentence-3",
              "text": "Since SC and OPSC are similar measures, we say OPRL finds higher-confidence queries than RLvLR* does."
            },
            {
              "iri": "Section-11-Paragraph-10-Sentence-4",
              "text": "In Figure 3, the partial area under the curve (AUC) of RLvLR* is 0.23 while the partial AUC of OPRL is 0.30, showing OPRL outperforms RLvLR* on query generation by 30%."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-12",
      "subtitle": "Related Work and Discussion",
      "paragraphs": [
        {
          "iri": "Section-12-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-12-Paragraph-1-Sentence-1",
              "text": "Previous work in rule learning from a KG is closely related to ours, but it is generally focused on Closed rules."
            },
            {
              "iri": "Section-12-Paragraph-1-Sentence-2",
              "text": "As discussed, Closed rules are less expressive than our OP rules and have a different application."
            },
            {
              "iri": "Section-12-Paragraph-1-Sentence-3",
              "text": "While OP rule learners aim to generate new facts, we aim to generate relevant queries for new facts."
            },
            {
              "iri": "Section-12-Paragraph-1-Sentence-4",
              "text": "There are some preliminary attempts towards learning existential rules from knowledge graphs."
            },
            {
              "iri": "Section-12-Paragraph-1-Sentence-5",
              "text": "In this short paper, the authors outline several directions for future research to handle existential rule learning, although they do not propose a learning system."
            }
          ]
        },
        {
          "iri": "Section-12-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-12-Paragraph-2-Sentence-1",
              "text": "We are unaware of any previous approach which produces relevant queries for link predictors in the knowledge graph completion process."
            },
            {
              "iri": "Section-12-Paragraph-2-Sentence-2",
              "text": "However, CHAI filters facts before supplying them to a link predictor, aiming to improve the prediction by focusing its attention on the more probable facts and discarding irrelevant ones."
            },
            {
              "iri": "Section-12-Paragraph-2-Sentence-3",
              "text": "It does not generate queries as OPRL does, and is highly dependent on the initial set of facts which it aims to filter."
            }
          ]
        }
      ]
    },
    {
      "iri": "Section-13",
      "subtitle": "Conclusion",
      "paragraphs": [
        {
          "iri": "Section-13-Paragraph-1",
          "sentences": [
            {
              "iri": "Section-13-Paragraph-1-Sentence-1",
              "text": "In this paper, we proposed a method for learning rules with free variables from Knowledge Graphs (KGs)."
            },
            {
              "iri": "Section-13-Paragraph-1-Sentence-2",
              "text": "Such rules can be used to generate queries soliciting missing facts."
            },
            {
              "iri": "Section-13-Paragraph-1-Sentence-3",
              "text": "Notably, the queries could be fed to link predictors, enabling a fully automated framework for KG completion."
            }
          ]
        },
        {
          "iri": "Section-13-Paragraph-2",
          "sentences": [
            {
              "iri": "Section-13-Paragraph-2-Sentence-1",
              "text": "We introduced the following novel components:"
            },
            {
              "iri": "Section-13-Paragraph-2-Sentence-2",
              "text": "(1) We propose OP rules, a fragment of function-free Horn rules, which allows us to mine rules with free variables while keeping the complexity of the learning phase manageable."
            },
            {
              "iri": "Section-13-Paragraph-2-Sentence-3",
              "text": "(2) We introduced a novel method to estimate the quality of each candidate rule based on its embedding representation."
            },
            {
              "iri": "Section-13-Paragraph-2-Sentence-4",
              "text": "(3) We proposed an efficient method to evaluate OP rules by exactly computing the quality of each rule using matrix and vector operations."
            },
            {
              "iri": "Section-13-Paragraph-2-Sentence-5",
              "text": "(4) We showed how OP rules can be used to generate highly relevant queries for missing links, introducing the first work on active knowledge graph completion."
            }
          ]
        },
        {
          "iri": "Section-13-Paragraph-3",
          "sentences": [
            {
              "iri": "Section-13-Paragraph-3-Sentence-1",
              "text": "Our experiments show that OPRL can learn rules for KGs with varying sizes and degrees of incompleteness."
            },
            {
              "iri": "Section-13-Paragraph-3-Sentence-2",
              "text": "We demonstrate the usefulness of the mined rules by applying them to three different KGs to infer relevant queries."
            }
          ]
        },
        {
          "iri": "Section-13-Paragraph-4",
          "sentences": [
            {
              "iri": "Section-13-Paragraph-4-Sentence-1",
              "text": "Our proposed method outperforms the baselines and shows its strength, especially in the complete KG, Poker, with 0.98 precision."
            }
          ]
        },
        {
          "iri": "Section-13-Paragraph-5",
          "sentences": [
            {
              "iri": "Section-13-Paragraph-5-Sentence-1",
              "text": "There remain some intriguing challenges for future work."
            },
            {
              "iri": "Section-13-Paragraph-5-Sentence-2",
              "text": "We plan to extend OPRL to learn rules with more complex shapes, such as stars, and with numerical attributes."
            },
            {
              "iri": "Section-13-Paragraph-5-Sentence-3",
              "text": "We plan to pair OPRL with a link predictor to form a unified framework for fully automated KG completion."
            },
            {
              "iri": "Section-13-Paragraph-5-Sentence-4",
              "text": "We will also trial OPRL in a setting for human-curated maintenance on an enterprise KG."
            }
          ]
        }
      ]
    }
  ],
  "summary": "Enterprise and public Knowledge Graphs (KGs) are known to be incomplete. Methods for automatic completion, sometimes by rule learning, scale well. While previous rule-based methods learn closed (non-existential) rules, we introduce Open Path (OP) rules that are constrained existential rules. We present a novel algorithm, OPRL, for learning OP rules.\n\nClosed rules complete a KG by answering queries of unclear origin, usually derived from a holdback test set in experimental settings. However, OP rules can generate relevant queries for KG completion. OPRL generates queries even when there is no closed rule to answer the query, or when the correct answer is a missing entity that is not present in the KG.\n\nFor OPRL to scale well, we propose a novel embedding-based fitness function to efficiently estimate rule quality. Additionally, we introduce a novel, efficient vector computation to formally assess rule quality.\n\nWe evaluate OPRL using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG. We find that OPRL mines hundreds of accurate rules from massive KGs with up to 8 M facts. The OP rules generate queries with precision as high as 98% and recall of 62% on a complete KG, demonstrating the first solution for active knowledge graph completion.\n\nCrown Copyright 2022 Published by Elsevier Inc. This is an open access article under the\n\nThe paper proposes a novel approach for completing knowledge graphs (KGs) by learning open path rules that generate queries to predict missing facts. Unlike traditional KG completion methods, this approach can identify missing entities and introduce new ones into the graph. The proposed method, OPRL, learns these rules from a given KG using an embedding-based heuristic function and evaluation method. The generated queries are relevant and can be used as input for link predictors to complete the KG.\n\nRule-based KG completion involves learning rules from a knowledge graph (KG) to infer new facts. Closed path (CP) rules are used, which consist of a head and body with variables that can be instantiated in the KG. The support of a rule measures how many instances it explains, while standard confidence and head coverage measure its explanatory power. Representation learning methods like RESCAL embed entities and predicates into a latent space to predict new facts.\n\nThe paper introduces open path (OP) rules for active knowledge graph completion, which are more expressive than closed path (CP) rules. OP rules have a linear shape and can be instantiated to infer questions rather than facts. The quality of mined OP rules is assessed using open path standard confidence (OPSC), open path head coverage (OPHC), and support degree (OPsupp). These metrics measure the proportion of entities that satisfy the rule's body or head, providing insights into the effectiveness of the mining process.\n\nThe paper proposes OPRL (OP Rule Miner), an algorithm to mine high-quality OP rules from a knowledge graph (KG) for a specific target predicate. The approach uses novel fitness and vector computation functions, as well as sampling and embedding-based methods to reduce KG size and improve scalability. The algorithm takes user parameters for maximum rule length and minimum quality scores, and outputs a set of mined OP rules.\n\nThe PathFinding() algorithm filters out low-quality rules by estimating their quality using two fitness functions: co-occurrence and open path. Co-occurrence measures similarity between entities, while open path evaluates rule quality based on predicate embeddings along a path of connected predicates. The hybrid approach combines both fitness functions to select top candidate rules.\n\nThe evaluation method, Evaluation(), assesses candidate rules based on sampled KGs for efficiency and then picks rules with OPsupp(r) \u2265 1. To compute OPSC and OPHC, it checks satisfiability of body atoms using an adjacency matrix representation of the KG. The method efficiently computes these measures by summing columns or rows of matrices to find distinct entities that satisfy head or body conditions.\n\nThe paper discusses how to use OP rules mined from Knowledge Graphs (KGs) for Active KG Completion (AKGC). The approach generates relevant questions that can be posed to an oracle or human expert. For AKGC, the task is to generate queries of the form P(?, e') and P(e, ?) based on predicate P in the KG. OP rules are used to induce these queries with a quantifiable confidence degree (CD). The CD is defined as the maximum OPSC of all rules inducing the query.\n\nThe paper evaluates OPRL, a system that generates relevant questions for knowledge graph completion. Unlike traditional link prediction approaches, OPRL focuses on asking relevant questions rather than answering them. The authors assume a perfect link predictor and evaluate their system by generating queries that can be used to infer new facts. They demonstrate the effectiveness of OPRL in mining quality rules from various knowledge graphs (KGs) and generate relevant queries with good recall and precision.\n\nOPRL assesses high-quality rule learning, comparing fitness function performance and reporting OPSC/OPHC scores against full benchmark KGs. The quality of rules mined from Wikidata and other datasets are presented, including two illustrative examples. An experiment shows that a hybrid fitness function can mine more quality rules than individual functions.\n\nThe paper evaluates the relevance of queries generated from OPRL-mined rules. Three baseline query sets (Prand) are developed and compared to OPRL-generated queries on three KGs: FB15KSE, YAGO2 core, and Poker. The results show that OPRL outperforms Prand by factors of 6, 2, and 9 respectively. Additionally, the paper investigates the sensitivity of OPRL's performance to the OPSC threshold and compares it with RLvLR* on query generation task.\n\nPrevious work in rule learning from a KG is closely related to ours, but it is generally focused on Closed rules. As discussed, Closed rules are less expressive than our OP rules and have a different application. While OP rule learners aim to generate new facts, we aim to generate relevant queries for new facts. There are some preliminary attempts towards learning existential rules from knowledge graphs. In this short paper, the authors outline several directions for future research to handle existential rule learning, although they do not propose a learning system.\n\nWe are unaware of any previous approach which produces relevant queries for link predictors in the knowledge graph completion process. However, CHAI filters facts before supplying them to a link predictor, aiming to improve the prediction by focusing its attention on the more probable facts and discarding irrelevant ones. It does not generate queries as OPRL does, and is highly dependent on the initial set of facts which it aims to filter.\n\nIn this paper, we proposed a method for learning rules with free variables from Knowledge Graphs (KGs). Such rules can be used to generate queries soliciting missing facts. Notably, the queries could be fed to link predictors, enabling a fully automated framework for KG completion.\n\nWe introduced the following novel components: (1) We propose OP rules, a fragment of function-free Horn rules, which allows us to mine rules with free variables while keeping the complexity of the learning phase manageable. (2) We introduced a novel method to estimate the quality of each candidate rule based on its embedding representation. (3) We proposed an efficient method to evaluate OP rules by exactly computing the quality of each rule using matrix and vector operations. (4) We showed how OP rules can be used to generate highly relevant queries for missing links, introducing the first work on active knowledge graph completion.\n\nOur experiments show that OPRL can learn rules for KGs with varying sizes and degrees of incompleteness. We demonstrate the usefulness of the mined rules by applying them to three different KGs to infer relevant queries.\n\nOur proposed method outperforms the baselines and shows its strength, especially in the complete KG, Poker, with 0.98 precision.\n\nThere remain some intriguing challenges for future work. We plan to extend OPRL to learn rules with more complex shapes, such as stars, and with numerical attributes. We plan to pair OPRL with a link predictor to form a unified framework for fully automated KG completion. We will also trial OPRL in a setting for human-curated maintenance on an enterprise KG.",
  "kg2text": [
    "OPRL, a novel algorithm for learning open path rules from knowledge graphs (KGs), enables inference of missing facts and generation of relevant queries. Unlike previous approaches that focused on closed rules, OPRL can learn constrained existential rules to complete KGs with varying sizes and degrees of incompleteness. The proposed method is effective over very large KGs and generates highly relevant queries for missing links, introducing the first work on active knowledge graph completion.",
    "OPRL, a novel algorithm for learning open-path rules from knowledge graphs with varying sizes and degrees of incompleteness, can generate queries with precision as high as 98% and recall of 62%. This approach introduces Open Path (OP) rules that are constrained existential rules used to generate relevant queries even when there is no closed rule or the correct answer is not present in the KG. OPRL uses these open-path rules to form a unified framework for fully automated knowledge graph completion, demonstrating its effectiveness on various datasets including Freebase, YAGO2, Wikidata, and Poker KG.",
    "OPRL, a novel algorithm for learning open path rules from Knowledge Graphs (KGs), can learn rules for KGs with varying sizes and degrees of incompleteness. It presents a method that learns constrained existential rules, also known as Open Path rules, to complete KGs. OPRL is effective over very large KGs and generates queries with precision as high as 98% and recall of 62%. The algorithm can be used to generate highly relevant queries for missing links, introducing the first work on active knowledge graph completion. This paper proposes a method called OPRL that learns constrained existential rules, also known as Open Path rules, to complete KGs.",
    "This paper proposes a novel algorithm for learning Open Path rules from Knowledge Graphs (KGs), which enables inference of missing facts and generation of relevant queries. The proposed OPRL algorithm learns constrained existential rules, also known as Open Path rules, to complete KGs with varying sizes and degrees of incompleteness. We evaluate the performance of OPRL using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG, demonstrating its effectiveness in generating highly relevant queries for missing links. The algorithm is capable of learning high-quality rules that can be used to generate queries with precision as high as 98% and recall of 62%. Furthermore, OPRL finds high-quality rules that are effective over very large KGs.",
    "The novel algorithm OPRL learns constrained existential rules, also known as Open Path rules, to complete Knowledge Graphs. These rules can generate relevant queries for missing links with precision as high as 98% and recall of 62%. The proposed method demonstrates the first solution for active knowledge graph completion. By pairing OPRL with a link predictor, we form a unified framework for fully automated KG completion. Our experiments show that OPRL can learn rules from Knowledge Graphs with varying sizes and degrees of incompleteness.",
    "We evaluate Open Path Rule Learning (OPRL) using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG. To scale well, we propose a novel embedding-based fitness function to efficiently estimate rule quality. Our algorithm effectively learns OP rules from a range of Knowledge Graphs (KGs), which can generate relevant queries for completing incomplete KGs. For instance, an example demonstrates how OP rules can generate highly relevant queries with precision as high as 98% and recall of 62%. We also present a novel approach to the problem of active knowledge graph completion, introducing the first work on this topic. This paper proposes a method called OPRL that learns constrained existential rules, also known as Open Path rules, to complete Knowledge Graphs.",
    "Our algorithm, OPRL, effectively learns open path rules from knowledge graphs. We evaluate its performance using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG, demonstrating high-quality rule mining for knowledge graph completion. The novel approach enables asking relevant questions to complete incomplete knowledge graphs with precision as high as 98% and recall of 62%. Furthermore, OPRL can be paired with a link predictor to form a unified framework for fully automated knowledge graph completion.",
    "We evaluate OPRL using adaptations of Freebase, YAGO2, Wikidata, and synthetic Poker Knowledge Graph. This novel algorithm finds high-quality rules that can be used to generate highly relevant queries for missing links, introducing the first work on active knowledge graph completion. The ability to learn Open Path (OP) rules with quantifiable qualities from Knowledge Graphs allows for the generation of relevant queries and active knowledge graph completion. OPRL is a method that learns constrained existential rules, also known as Open Path rules, to complete Knowledge Graphs. Our algorithm is effective over very large KGs, generating queries with precision as high as 98% and recall of 62%. This paper proposes a unified framework for fully automated KG completion by pairing OPRL with a link predictor.",
    "OPRL finds high-quality rules that can generate relevant queries for knowledge graph completion. These OP rules are constrained existential rules used to complete missing links, introducing the first solution for active knowledge graph completion. The novel algorithm OPRL learns Open Path rules from a range of KGs and generates highly relevant queries with precision as high as 98% and recall of 62%. This paper proposes a method called OPRL that learns constrained existential rules, also known as Open Path rules, to complete Knowledge Graphs.",
    "This paper proposes OPRL (Open Path Rule Learning), an algorithm that learns constrained existential rules for completing incomplete Knowledge Graphs. The novel method can generate hundreds of accurate rules from massive KGs with up to 8 million facts, making it effective over very large datasets. By mining Open Path rules with measurable qualities from KGs, the proposed approach enables active knowledge graph completion and introduces a new paradigm in rule-based query generation for missing links.",
    "We propose an algorithm, OPRL, for learning open path rules from a knowledge graph. Our novel OPRL can learn plausible rules that are considered likely to be true or accurate, used for knowledge graph completion. We pair OPRL with a link predictor to form a unified framework for fully automated KG completion. The proposed algorithm is designed to efficiently compute Open Path Support and Overall Path Hit Count measures for evaluating candidate rules in the context of active knowledge graph completion. Our novel hybrid fitness function outperforms the fitness function adapted from RLVLR, demonstrating that OPRL can mine quality open path rules from a range of Knowledge Graphs. Furthermore, queries generated from OPRL's rules are relevant with good recall and precision in multiple KGs.",
    "The novel algorithm OPRL demonstrates the first solution for active knowledge graph completion, which learns constrained existential rules to generate relevant queries. This approach has a broader term as AKGC task and can be applied to various domains. The system uses open path rules (OP) mined from a knowledge graph to ask the best questions to complete a KG. A novel vector computation allows evaluating OP rules against massive KGs, computing quality measures such as OPSC and OPHC. In addition, link predictors are used to fully automate KG completion.",
    "The quality assessment of candidate rules using metrics OPSC and OPHC, evaluated based on the entire knowledge graph. A novel algorithm, Open Path Rule Learner (OPRL), capable of learning constrained existential rules for knowledge graphs with varying sizes and degrees of incompleteness. The process of predicting and generating relevant queries in order to complete a Knowledge Graph. Two sets of experiments: evaluations of OPRL for learning open path rules and generating relevant queries from massive knowledge graphs.",
    "The proposed system learns Open Path (OP) rules for generating relevant queries in knowledge graph completion. The first method to learn rules to generate relevant questions automatically, our algorithm OPRL effectively handles very large KGs and can induce most relevant queries over full KBs. By mining quality OP rules from massive knowledge graphs, we enable active knowledge graph completion tasks such as completing missing links and filling gaps. Our novel approach uses constrained existential rules to connect entities satisfying a subject predicate to entities forming the object argument of another predicate along a path.",
    "The AKGC task involves generating queries of the form P(?, e') and P(e, ?) for entities e and e' occurring in a Knowledge Graph (KG), given a predicate P. The process of using mined Open Path rules for Active Knowledge Graph Completion can predict answers for known unknowns. A fully automated framework for KG completion uses learned rules with free variables to generate queries and predict missing links in knowledge graphs. OPRL, an algorithm that learns constrained existential rules, can learn rules for KGs with varying sizes and degrees of incompleteness. By inferring new facts from existing ones, we can complete a Knowledge Graph (KG). The compositional embeddings represent predicates as weight matrices and use a product calculus for scoring to model knowledge graphs.",
    "We propose a novel method for learning open-path rules from knowledge graphs, which enables inference of missing facts and generation of relevant queries. Our approach, OPRL, learns constrained existential rules that can generate queries soliciting missing facts in incomplete Knowledge Graphs (KGs). We demonstrate the effectiveness of our algorithm by applying it to a synthetic Poker KG and comparing its performance with traditional methods for knowledge graph completion. The results show that OPRL outperforms probabilistic baselines and is capable of generating relevant questions for completing incomplete KGs.",
    "The problem of active knowledge graph completion (AKGC) involves learning open path rules from a range of public Knowledge Graphs. This approach enables asking relevant questions to complete the KG instead of suggesting missing facts. Our novel algorithm, OPRL, learns hundreds of accurate rules from massive KGs with up to 8 million facts. We present this algorithm as an effective solution for completing knowledge graphs and generating high-quality rules. The full benchmark KGs demonstrate its performance in finding open path rules that can generate relevant queries.",
    "In this paper, we propose OPRL, a novel method for learning open path rules from knowledge graphs (KGs). These rules enable inference of missing facts and generation of relevant queries to complete incomplete KGs. We demonstrate that OPRL outperforms RLvLR* in terms of quality measures such as OPSC and OPHC when evaluated against massive KGs. Furthermore, we show that our approach can mine these large-scale graphs in a reasonable time frame. Our method is particularly useful for knowledge graph completion, where the goal is to predict missing facts even when entities involved in those facts may be absent from the KG. We also highlight the importance of generating queries with preference given to those with higher probability in the KG, rather than simply generating every possible query without consideration for comparative value.",
    "The OP rules from Knowledge Graphs (KGs) have been learned using the rule- based knowledge graph. These open path rules can generate relevant queries for missing links, which are then used to complete the KG. The relevance of these queries induced from OPRL-mined rules is assessed in our second set of experiments. In this process, entities e and e' occurring in the KG have a broader term as 'a KG'. Additionally, OPRL finds high quality rules through rule mining. Section 5 presents the process for generating relevant queries derived from the learnt OP rules. The OP rule can now mine OP rules with measurable qualities from KGs. A hybrid fitness function that combines both f_ co(.) and f_op(.) is capable of mining more quality rules than either of these functions individually. Furthermore, three KGs have been used to evaluate the relevance of queries generated by OPRL. In this way, we go beyond link prediction to infer relevant queries for missing links, which is Active KGC. The knowledge graph completion approaches include rule- based knowledge graph completion and active knowledge graph completion.",
    "We present OPRL, a novel algorithm for learning Open Path rules from Knowledge Graphs. This approach enables us to generate relevant queries that predict answers for known unknowns. In contrast to traditional knowledge graph completion methods, our method can learn constrained existential rules and produce instantiations that cannot be inferred by closed path rules. Furthermore, we demonstrate the effectiveness of OPRL in generating high-quality Open Path rules using 20 randomly selected predicates from FB15KSE. Our results show that OPRL is capable of learning rules for Knowledge Graphs with varying sizes and degrees of incompleteness.",
    "The OPRL algorithm excels at learning open path rules from knowledge graphs, particularly on the YAGO2 core dataset. By applying these rules to three different KGs, we can assess their quality over the entire graph. The problem of knowledge graph completion involves predicting answers for known unknowns and is closely related to rule- based knowledge graph completion. Our active knowledge graph completion task uses a combination of OP language queries and mined rules to ask the best questions to complete a given KG. In this way, we can predict missing facts and generate relevant queries from incomplete Knowledge Graphs.",
    "The Poker KG, with hundreds of accurate rules from massive knowledge graphs containing up to 8 million facts, has a broader term - their relations. This novel algorithm OPRL mines these rules for completing and querying large-scale knowledge graphs. The problem of rule-based knowledge graph completion is addressed by predicting answers for known unknowns using link predictors in the knowledge graph completion process. A key innovation is the evaluation of Open Path (OP) rules against a massive KG to compute quality measures, such as OPSC and OPHC. This approach has been applied to various public Knowledge Graphs, including Freebase, YAGO2, Wikidata, and synthetic Poker KG. The results demonstrate that high-quality OP rules can be mined from these graphs using the OPRL algorithm.",
    "In knowledge graph completion, OPRL learns open path rules from a given KG to generate relevant queries for missing links. The full benchmark KGs are used as a broader term for public Knowledge Graphs. Rule learners like OPRL assess their quality over the whole KG. Our algorithm is effective in very large KGs and complements tools like RLVLR and ScaleKB, which employ closed path rules. Closed rules can complete a traditional knowledge graph by inferring new facts from existing ones. Representation Learning for KG Completion uses embedding-based methods to learn representations of entities and relationships. The quality assessment over the whole KG is crucial in active knowledge graph completion tasks.",
    "The proposed method, Open Path Rule Learning (OPRL), leverages closed path rules to learn constrained existential rules from vast Knowledge Graphs. OPRL can generate relevant queries for KG completion by learning open-path rules that are strictly more expressive than traditional CP rules. In a trial setting for human-curated maintenance on an enterprise KG, the algorithm demonstrated its effectiveness in completing missing links and introducing new entities. The distribution of mined rules shows high-quality OPSC scores, indicating the potential of OPRL to handle vast KGs efficiently.",
    "The authors of this paper, referring to themselves as 'We', present a novel method for learning open path rules from knowledge graphs. This approach has been successfully applied in trial OPRL settings on an enterprise KG, demonstrating its effectiveness over very large datasets. The problem of rule-based knowledge graph completion is addressed by introducing Open Path (OP) rules and the algorithm OPRL, which generates queries with precision as high as 98% and recall of 62%. Our proposed method has been evaluated using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG. The results show that our novel heuristic function for mining OP rules uses RESCAL to exceed FB15KSE in terms of performance.",
    "The problem of rule-based knowledge graph completion involves learning link predictors that can complete a Knowledge Graph (KG) by predicting relationships between entities. Closed rules are less expressive than OP rules, which generate queries with precision as high as 98% and recall of 62%. In contrast to traditional approaches, we predict the existence of missing facts even when an entity involved in the missing fact may be absent from the KG. Our proposed method for learning Open Path (OP) rules uses a novel embedding-based fitness function to efficiently estimate rule quality. OPRL generates queries that are highly relevant for missing links and can scale well by using this approach.",
    "In this paper, we introduce OPRL, an algorithm for learning open path rules from knowledge graphs. These rules enable active knowledge graph completion by generating relevant queries that can be used to complete massive KGs with up to 8 million facts. Unlike traditional knowledge graph completion approaches, our method predicts the existence of missing facts even when entities involved in the missing fact may not be present in the KG. We demonstrate the effectiveness of OPRL over very large KGs and show how it can generate highly relevant queries for completing incomplete Knowledge Graphs.",
    "OPRL, a novel algorithm for learning Open Path rules from knowledge graphs (KGs), enables inference of missing facts and generation of relevant queries. By leveraging embedding representations to derive fitness functions, OPRL can efficiently evaluate rule performance. This approach is particularly useful when there are no closed path rules available or the correct answer is a missing entity not present in the KG. The proposed method has been evaluated using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG, demonstrating its effectiveness in completing incomplete knowledge graphs.",
    "Our proposed method, OPRL, learns open-path (OP) rules from knowledge graphs to generate relevant queries. In contrast, we predict the existence of missing facts even when an entity involved in the missing fact may be absent from the KG. The OP rules generate queries with precision as high as 98% and recall of 62% on a complete KG, demonstrating the first solution for active knowledge graph completion. We present a novel algorithm, OPRL, for learning OP rules that can mine more quality rules than either of these functions individually. This approach enables active KG completion by predicting missing facts and introducing new entities.",
    "In order to repair working knowledge graphs, link predictors need to generate relevant questions or queries that can help complete the graph. This process involves predicting missing facts even when an entity involved in the fact may be absent from the graph. The approach used by our active knowledge graph completion task is different from traditional link prediction systems, which require initial query inputs. Instead, we propose a novel algorithm for learning constrained existential rules to efficiently estimate rule quality and improve scalability. Our method initializes a set of entities based on the number of entities involved in a target predicate and then generates OP rules using embeddings-based fitness function. This approach has been shown to be effective in completing knowledge graphs by filling in missing information.",
    "The Active Knowledge Graph Completion (AKGC) system, our AGKGC, uses Open Path (OP) rules mined from a knowledge graph to generate relevant questions for missing links. This approach learns constrained existential rules that can produce instantiations that cannot be inferred by closed path rules. The OPRL algorithm does this by learning operational patterns and relying on an embedding representation. Two fitness functions are proposed: co-occurrence, which captures the weight of connections between sequential entities along a path; and open path, both derived from entity and predicate embeddings. These novel methods enable active knowledge graph completion tasks to identify missing entities in a Knowledge Graph. In contrast, traditional knowledge graph completion approaches rely on human expertise or domain-specific rules.",
    "In knowledge graph completion, OP rules can generate relevant queries for completing incomplete Knowledge Graphs. The two alternative quality estimation functions used are co-occurrence and open path. Our proposed method, OPRL, learns Open Path rules to generate queries with precision as high as 98% and recall of 62%. We evaluate OPRL using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG. The remaining rules are the final result of the algorithm, which can learn plausible rules over popular benchmark KGs in less than two hours.",
    "Our algorithm learns open path rules from knowledge graphs, which enables active completion by predicting missing facts and introducing new entities. We can now mine OP rules with measurable qualities from KGs using methods such as representation learning for KG completion. The following two OP rules mined from Wikidata have their respective OPSC and OPHC values. By learning these open path rules to derive queries, we can propose missing facts in the knowledge graph. For instance, let r be an OP rule of the form (2), which generates queries about predicate P and entities in the KG. We interpret this kind of rule as a closed path CP rule with universal quantification of all variables at the outside, used to infer a fact that instantiates the head of the rule by finding an instantiation of its body in the knowledge graph.",
    "In knowledge graph completion, previous approaches focused on learning closed rules. However, this paper introduces Open Path (OP) rules and proposes OPRL algorithm for generating relevant queries even when there's no closed rule or when the correct answer is a missing entity not present in the KG. The mined rules can be used to generate hundreds of accurate rules from massive knowledge graphs with up to 8 million facts. Moreover, OPRL generates queries that are highly relevant and accurate, making it an effective approach for active knowledge graph completion.",
    "In recent years, knowledge graph completion has become increasingly important for completing and inferring missing information within structured representations of entities and their relationships. To address this challenge, researchers have proposed various methods, including rule-based approaches that leverage high-quality rules to generate relevant queries about missing facts or entities. One such approach is OPRL (Open Path Rule Learning), which learns constrained existential rules from knowledge graphs to produce instantiations that cannot be inferred by closed path rules. In their evaluation of OPRL, the authors demonstrate its effectiveness over very large KGs and show how it can repair working KGs by generating relevant queries about missing links. By leveraging open path rules (OP) in this way, researchers can generate high-quality rules for knowledge graph completion that are both accurate and complete.",
    "Knowledge graph completion approaches, such as rule-based knowledge graph completion and link predictors in the knowledge graph completion process, are used to complete missing information in a knowledge graph. The problem of knowledge graph completion involves predicting specific missing facts. Then, we can infer and assert new facts in the KG based on existing relationships between entities. Our proposed method uses OP rules that generate relevant queries for KG completion. These queries are generated even when there is no closed rule to answer the query or when the correct answer is a missing entity not present in the KG. The building methods involve asserting some erroneous facts, which can be corrected using novel approaches like our hybrid fitness function. This approach outperforms the adapted fitness function from RLVLR and generates queries that are relevant for knowledge graph completion.",
    "In knowledge graph completion, a novel algorithmic approach is required to check the satisfiability of body atoms for all candidate rules. This involves learning constrained existential rules, such as open path rules, which can generate relevant queries even when there is no closed rule or the correct answer is not present in the knowledge graph. For example, an OP rule like r: P1(x, z0) \u2192 P2(z0, z1) \u2227 P3(z1, y) can be used to predict missing facts and complete a full benchmark KGs. Our proposed method uses link predictors in the knowledge graph completion process to obtain embeddings for predicates and arguments, which enables us to infer new facts and assert them into the KG.",
    "In this paper, we propose OPRL (Open Path Rule Learning) as a novel method for learning open path rules from knowledge graphs. The process of drawing logical conclusions from existing facts in a knowledge graph based on an existential rule results in the addition of new facts to the graph. We evaluate OPRL using adaptations of Freebase, YAGO2, Wikidata, and a synthetic Poker KG, demonstrating its effectiveness over very large knowledge graphs. Our algorithm is designed for learning open path rules that generate relevant queries for completing knowledge graphs.",
    "In this study, we propose a novel algorithm called OPRL that learns hundreds of accurate rules from massive knowledge graphs with up to 8 million facts. These Open Path (OP) rules are constrained existential rules used for knowledge graph completion and can produce instantiations that cannot be inferred by closed path rules. Our proposed method uses an inference module that derives queries from Knowledge Graph (KG) facts together with OP rules found by Algorithm 1, which takes user parameters for maximum rule length and least acceptable Open Path scoring function scores. Additionally, we introduce a novel, efficient vector computation to formally assess rule quality. This approach is particularly useful in the context of active knowledge graph completion tasks, where link predictors need to repair working KGs.",
    "In this paper, we propose OPRL (Open Path Rule Learner), a novel algorithm for learning Open Path rules that generate queries with precision as high as 98% and recall of 62% on complete knowledge graphs. Our approach involves implementing an inference module to derive queries from KG facts together with OP rules found by Algorithm 1. This allows us to efficiently evaluate the quality of Open Path rules in massive knowledge graphs, such as public Knowledge Graphs or vast rule-based knowledge graph datasets. By leveraging entity embeddings and two fitness functions - co-occurrence and open path - we demonstrate a significant improvement over previous approaches for active knowledge graph completion.",
    "In traditional knowledge graph completion methods, specific facts that are missing from the Knowledge Graph (KG) can be inferred by Closed rules. A rule-based approach involves learning constrained existential rules to complete a KG by answering unclear queries or generating relevant questions. Our active knowledge graph completion task addresses problems in traditional knowledge graph completion and uses novel embedding- based fitness functions to evaluate the quality of learned Open Path rules. OPRL, an algorithm for inducing logical rules from large KGS, can learn plausible rules over popular benchmark KGS with millions of facts and entities in less than two hours. The AKGC task involves generating queries of the form P(?, e') and P(e, ?) for entities e and e' occurring in a KG, given a predicate P.",
    "In knowledge graph completion, our proposed method uses novel embeddings to estimate rule quality. This approach enables efficient estimation of rule quality and improves scalability for active knowledge graph completion tasks. By leveraging OPRL's embedding-based fitness function, we can efficiently complete public Knowledge Graphs by inferring new facts based on existing rules. Moreover, the co-occurrence fitness function helps capture the weight of connections between sequential entities along a path, allowing us to evaluate rule quality effectively.",
    "In this study, we propose OPRL (Open Path Rule Learning), an algorithm that generates queries even when there is no closed rule to answer the query or when the correct answer is a missing entity not present in the Knowledge Graph. Our proposed method combines both f_co(.) and f_op(.) fitness functions derived from embedding representations to efficiently estimate rule quality. OPRL can learn high-performing rules with free variables, which are constrained existential rules that generate relevant queries for knowledge graph completion. By leveraging vector embeddings, our algorithm demonstrates its effectiveness in repairing working Knowledge Graphs (KGs) by generating and processing relevant questions or queries.",
    "The paper presents Rule-Based KG Completion, an algorithm that learns constrained existential rules from a knowledge graph. The OP rules are used to generate relevant queries for completing traditional knowledge graphs. Section 5 describes the process of generating these queries derived from learned Open Path rules. Hundreds of accurate rules were mined from massive knowledge graphs with up to 8 million facts using RESCAL embeddings, which capture intrinsic properties and relationships between entities. This novel approach can be applied to various domains where knowledge graph completion is necessary.",
    "In knowledge graph completion, generating all possible queries without considering their relative importance or relevance to the Knowledge Graph (KG) can be a challenge. To address this issue, we introduce Open Path Rules (OPRL), which are constrained existential rules used for learning and generating open-ended questions from KGs to guide discovery of unknown entities. OPRL generates queries even when there is no closed rule to answer the query, making it an effective method for completing incomplete Knowledge Graphs. By leveraging entity embeddings built from knowledge graph pairs (E,F), we can learn representations that capture the relationships between sequential entities along a path in an open-path rule. Our proposed method, OPRL, learns Open Path rules about predicate P in the head and generates relevant questions or queries to complete missing links in KGs.",
    "The ability to learn Open Path (OP) rules with quantifiable qualities from Knowledge Graphs (KGs), allowing for the generation of relevant queries and active knowledge graph completion. Techniques, such as OP rule learners, are used to achieve this goal by learning constrained existential rules that predict missing entities and facts in a KG. The proposed method learns OP rules to derive queries, which enables active KG completion by predicting missing facts and introducing new entities. This approach is particularly useful for public Knowledge Graphs, where the system can propose missing facts based on learned patterns.",
    "In the context of multiple knowledge graphs (KGs), a rule-based approach has been proposed to learn open path rules from KGs. This method, known as OPRL, learns existential rules that generate relevant queries about missing links in incomplete KGs. The quality of these rules is estimated using two fitness functions: the open path fitness function and the co-occurrence fitness function. A high-performing link-predicting model built for a working KG can be used to complete the graph by generating queries with precision as high as 98% and recall of 62%. Furthermore, OPRL has been shown to generate relevant queries that are useful in completing incomplete KGs.",
    "In a knowledge graph (KG), you have built a high-performing link-predicting model. The embeddings for predicates and arguments in the sample KG are computed to estimate rule quality. IncPathFinding, an algorithm for learning Open Path rules, generates queries even when there is no closed rule or when the correct answer is a missing entity not present in the KG. RLvLR* and OPRL algorithms learn constrained existential rules that generate relevant queries for knowledge graph completion. The question remains whether to prioritize generating queries based on their likelihood within the KG or hold out facts from your KG to predict those same facts, which are only absent because they are needed to generate the queries.",
    "Unlike earlier work, we mine Open Path (OP) rules from knowledge graphs. It does not generate queries as OPRL rules are learned over the training data. The quality assessment of candidate rules using metrics OPSC and OPHC evaluated based on the entire knowledge graph. We implement an inference module that derives queries from KG facts together with OP rules found by Algorithm 1, which generates relevant queries even when there is no closed rule to answer the query or when the correct answer is a missing entity not present in the Knowledge Graph. Our proposed method learns existential rules from knowledge graphs and uses them to generate queries of the form P(?, e') and P(e, ?).",
    "To efficiently estimate rule quality, we propose a novel embedding-based fitness function for OPRL. This approach requires building methods to construct or develop something. A method is needed to check the satisfiability of body atoms of all candidate rules using an algorithm. For learning OP rules, we need to consider missing entities that are not present in the knowledge graph and generate queries with preference given to those with a higher probability. The performance of OPRL queries refers to evaluation metrics such as precision, recall, and F1-score. We implement an inference module that derives queries from KG facts together with OP rules found by Algorithm 1. Our proposed method learns open path rules using existential rules with different forms than conventional closed-path rules for knowledge graph completion tasks.",
    "OPRL, a novel algorithm for learning Open Path (OP) rules, has been developed to generate relevant queries for knowledge graph completion. Techniques such as OPRL do not rely on traditional methods of rule-based knowledge graphs and instead use embeddings for predicates and arguments in sample KGs. The mined rules are constrained existential rules that can be used to generate highly relevant queries even when there is no closed rule or missing entity present in the Knowledge Graph. In this paper, we assume a perfect link predictor that can answer any question with a correct answer when such an answer exists. Our questions in this paper aim to evaluate OPRL's performance over full benchmark KGs and demonstrate its ability to generate high-performing rules about target predicates.",
    "In this knowledge graph, we have an instantiation of the body of the rule in the KG, which represents a specific instance or occurrence of the core content or substance of a rule within a knowledge graph. This entity has a broader term 'KG', which refers to a collection of data that organizes information into interconnected entities and relationships. The RLVLR system is used for learning existential rules from these knowledge graphs, allowing for automatic completion methods to curate them. Furthermore, we have the top 10% of OP rules according to the fitness function, which are proposed using logical rules or vector embeddings. These rules can be used to generate queries soliciting missing facts in Knowledge Graphs, enabling active knowledge graph completion.",
    "In knowledge graph completion, two quality estimation methods are derived from embedding representations: co-occurrence and open path. These fitness functions can be applied to various KGs, including full benchmark KGs and public Knowledge Graphs. The OP rules learned by Open Path Rule Learner (OPRL) algorithm can generate instantiations that cannot be inferred by closed path rules. Our proposed method, OPRL, is an efficient approach for learning constrained existential rules from a given knowledge graph. Hundreds of accurate rules have been mined from massive KGs with up to 8 million facts using this novel technique.",
    "In this study, we introduce Open Path (OP) rules that are constrained existential rules. These OP rules can generate relevant queries for knowledge graph completion and have a more linear shape than closed path rules. We propose an algorithm called IncPathFinding to learn these OP rules from massive knowledge graphs with up to 8 million facts. Our proposed method uses logical rules or vector embeddings, which refer to the methods used for learning and representing knowledge graph completion models. The final result of our algorithm is a set of accurate OP rules mined from three different KGs, which generate queries with precision as high as 98% and recall of 62%. Furthermore, we demonstrate that even when there is no closed rule or when the correct answer is a missing entity not present in the Knowledge Graph, our proposed method can still learn to predict these facts. This approach has significant implications for knowledge graph completion and query generation.",
    "Knowledge Graphs (KGs) have long been recognized for their power in modeling and storing massive quantities of weakly-structured data. Traditional knowledge graphs represent relationships between entities, concepts, and facts in a structured manner. However, with the rise of enterprise and public KGs, there is an increasing need to learn rules that can generate open-ended questions about missing facts in these graphs. Our proposed method for learning OP rules from KGs has shown great promise in this regard. By leveraging the power of KGs and using methods such as Active KGC, we can now mine OP rules with measurable qualities from KGs. This allows us to not only complete incomplete knowledge graphs but also generate relevant queries that can be used to infer missing links.",
    "Our proposed method, which learns open path rules for generating relevant queries in knowledge graph completion, leverages a novel embedding-based fitness function to estimate the quality of learned OP rules. This approach scales well and can handle large-scale datasets. The process involves proposing OP rules from a fragment of function-free Horn rules, using a high-performing link-predicting model built for the KG as an oracle or automated query generator in Active Knowledge Graph Completion. Our algorithm learns open path rules that are constrained existential rules, which can generate relevant queries even when there is no closed rule to answer the query or when the correct answer is a missing entity not present in the Knowledge Graph.",
    "In vast knowledge graphs, learning open path rules and deriving relevant queries can facilitate active completion. By building methods that learn OP rules to derive queries, we can generate highly relevant questions for missing links. RESCAL captures rich interactions amongst entities and predicates in a KG, enabling the prediction of new facts. The process for generating relevant queries derived from learnt OP rules involves embedding representations into a latent space and reconstructing the KG based on these learned embeddings.",
    "In the realm of knowledge graph completion, our proposed system excels by learning Open Path rules that are constrained existential rules. This novel approach initializes a set of entities based on predicate involvement and generates relevant queries using embeddings-based fitness functions. The method has been tested on vast KGs and public Knowledge Graphs, demonstrating its scalability and effectiveness in completing incomplete knowledge graphs. Furthermore, our proposed system can induce queries of the form P(?, e') and P(e, ?) about a given concept or property P. This capability is particularly useful for human- curated maintenance on enterprise KGs.",
    "In traditional knowledge graph completion, we address problems that fail to identify missing facts and generate relevant questions. To overcome these limitations, novel components introduce OP rules from KGs. These constrained existential rules are learned using logical rules or vector embeddings, which refer to methods used for learning and representing knowledge graph completion models. The process of transforming entities and predicates into a latent space followed by reconstructing the KG based on the learned representations is crucial in predicting new facts. Additionally, we introduce a novel, efficient vector computation to formally assess rule quality. OP rules from KGs are used to generate relevant queries for completing incomplete Knowledge Graphs.",
    "In this paper, we address problems with traditional knowledge graph completion methods that fail to identify missing facts and generate relevant questions for completing a Knowledge Graph. To mine a KG for high-quality OP rules about a specific target predicate in the head P, novel algorithmic components are proposed, including proposing OP rules, learning OP rules based on an embedding representation, and evaluating OP rules using matrix and vector operations. Hundreds of accurate rules from massive KGs with up to 8 M facts have been mined using Open Path Rule Learner (OPRL), a system that learns constrained existential rules from knowledge graphs.",
    "In this knowledge graph, we have various entities and predicates that describe their relationships. The co-occurrence fitness function for open path rules estimates rule quality by aggregating pairwise local occurrences of predicate embeddings along a chain of predicates. This method is used to compute Open Path Support (OPSC) and Overall Path Hit Count (OPHC) measures for evaluating candidate rules in the context of active knowledge graph completion. Our proposed system, OPRL, learns open path rules from massive knowledge graphs by generating relevant questions automatically and mining quality OP rules. It uses a novel algorithm that combines two fitness functions: co-occurrence or open path, both derived from embedding representations.",
    "In this study, we propose an efficient method to exactly compute the quality of each rule by matrix and vector operations. This novel algorithm learns constrained existential rules (Open Path rules) from a knowledge graph, generating relevant queries for completion. The proposed fitness function estimates the quality of learned Open Path rules based on embedding representations of their predicates. Our approach efficiently computes measures such as OPSC and OPHC to evaluate candidate rules in active knowledge graph completion.",
    "In this study, we propose a novel method for learning constrained existential rules from knowledge graphs. This approach builds upon building methods and has been shown to be effective in generating relevant queries for missing links. The mined rules are used as input to train a high-performing link-predicting model built for the KG. We also demonstrate how compositional embeddings can estimate the quality of an OP rule based on its predicates, which is crucial for active knowledge graph completion. Furthermore, we show that RLVLR algorithm can learn CP rules by defining a similarity scoring function based on argument embeddings. The AKGC task involves generating queries of the form P(?, e') and P(e, ?) given predicate P, where each query corresponds to an unknown entity or relationship in the KG.",
    "In this study, we propose an efficient method to evaluate Open Path rules by exactly computing the quality of each rule using matrix and vector operations. Our proposed method builds upon Algorithm 1, which extends a previously generated OP rule by appending new body predicates and learning short rules for rightmost predicates. The algorithm uses two fitness functions: co-occurrence or open path, both derived from embedding representations. We demonstrate that even for Poker, recall shows that there are relevant queries that were not generated using the learnt rule. Our proposed method is particularly useful in Knowledge Graph completion tasks, where specific facts missing from the KG can be inferred by Closed rules.",
    "The task of knowledge graph completion approaches involves evaluating link prediction methods for completing missing information. Top candidate rules are selected based on their fitness values, using either co-occurrence or open path functions derived from entity embeddings. The Knowledge Graph (KG) can be thought of as a massive quantity of weakly-structured data modeled and stored using a technology that allows information to be added in an arbitrary manner. Public Knowledge Graphs provide access to various entities, concepts, and relationships. Rule-based link predictors like RLVLR learn existential rules from knowledge graphs for completing incomplete KGs. Methods for automatic completion sometimes involve rule learning and scale well. An instantiation of the body of a rule within a KG refers to an instance or occurrence of its core content. Our active knowledge graph completion task involves generating constrained existential rules to complete a Knowledge Graph by answering unclear queries or generating relevant questions. The relationships between entities in a knowledge graph are crucial for understanding their connections.",
    "The RESCAL algorithm learns embedding representations of entities and relationships. It uses high quality rules to generate relevant queries for knowledge graph completion, allowing extensions up to a certain depth using IncPathFinding(). The OP rule learning method OPRL finds constrained existential rules in massive KGs, which are then used by an inference module to derive queries from KG facts. This process is done in shortest-first order and uses Algorithm 1 to find the correct path. Additionally, P4(z2,y) is a logical rule that represents an existential rule about entities z2 and y. The OPRL algorithm also learns open path rules from a KG using techniques such as co-occurrence fitness functions and pairwise local fitness functions. Furthermore, Section 4 proposes the OP rule learning method OPRL to learn constrained existential rules from massive KGs.",
    "The RESCAL algorithm learns representations of entities and relationships, which are used to evaluate OP rules. The proposed method efficiently computes the quality of each rule by matrix and vector operations. A sampled KG can be a subset of a traditional knowledge graph, where facts represent interconnected entities. Our novel hybrid fitness function uses embeddings-based fitness functions for learning constrained existential rules from massive KGs. To compute OPSC and OPHC, we require a method to check the satisfiability of body atoms of all candidate rules. The state-of-the-art rule-based link predictor is an algorithm that learns open path rules to generate relevant queries for knowledge graph completion.",
    "In this paper, we propose an efficient method to evaluate OP rules by exactly computing the quality of each rule using matrix and vector operations. Our proposed algorithm combines both closed rule fitness function (f_co(.)) and OP rule fitness function (f_op(.)) to efficiently estimate rule quality. We also introduce a novel approach for learning open path rules from knowledge graphs, including a novel embedding-based heuristic function and evaluation method. The proposed method is shown to be effective in generating high-quality OP rules about specific target predicates P, mined from massive knowledge graph K'.",
    "In traditional knowledge graphs, missing entities can lead to incomplete information. To address this issue, RESCAL learns representations of entities and relationships using embeddings. In industrial applications, link prediction models arise from queries that require completing missing links in a graph. Our proposed method introduces novel rules for learning existential rules from knowledge graphs. By combining closed-path and open-path rule fitness functions, we can efficiently estimate the quality of these rules. Furthermore, our experiments demonstrate the effectiveness of this approach.",
    "In recent years, there has been significant interest in developing novel methods for learning open path rules (OPRL) from large-scale knowledge graphs. One key challenge in this area is designing effective fitness functions that can accurately evaluate and rank OP rules. In particular, a hybrid fitness function that combines the strengths of both co-occurrence-based and open-path-based evaluation metrics has been proposed as a promising approach for improving the performance of OPRL algorithms. Furthermore, the development of novel link prediction models, such as RESCAL, which utilize vector embeddings to capture semantic relationships between entities, has also contributed significantly to advances in this field. In addition, the ability to generate relevant queries for missing links in knowledge graphs using open-path rules learned from training data is a crucial aspect of industrial applications of link prediction models.",
    "In a fully automated KG completion, methods are used to induce queries of the form P(?, e') and P(e, ?) from open path rules. The number of entities that satisfy the body of a rule can be induced using these queries. A high-performing link-predicting model built for the Knowledge Graph (KG) is then used as an oracle or automated query generator in Active Knowledge Graph Completion. This process involves embedding the entities and predicates of a given KG into a latent space, reconstructing the KG based on learned embeddings to predict new facts, and using rules to induce queries even when there is no closed rule to answer the query. The open path support for these rules can be quantified by measuring the number of entities that instantiate a variable z0 to satisfy both the body and head parts of an open path rule.",
    "In this study, we propose an innovative approach to evaluate OP rules by leveraging knowledge graph completion models. Our method learns constrained existential rules (Open Path rules) that can generate relevant queries for missing links in incomplete Knowledge Graphs. We demonstrate the effectiveness of our proposed algorithm on three different KGs and show its ability to rapidly estimate a rule's quality. Furthermore, we introduce a novel, efficient vector computation to formally assess rule quality. Our approach has been tested on various datasets, including YAGO2, which is not supported by RESCAL. The results highlight the potential benefits of learning latent representations from unobserved but intrinsic properties of entities and their relations.",
    "In this context, we propose a novel embedding-based fitness function to estimate the quality of learned Open Path rules. This approach leverages embeddings to efficiently evaluate rule performance and can be used with Algorithm 1 for learning open-path rules from knowledge graphs. The proposed method also includes techniques such as link predictors that answer each query with a sequence of ranked entities, allowing us to generate relevant questions which can be posed to an oracle or human expert. Furthermore, we use OP rules to mine novel fitness functions and models, often expressed as logical rules or vector embeddings, learned from knowledge graphs to predict missing facts and generate relevant queries for curating tasks including link prediction.",
    "We assess the candidate rules from knowledge graphs, introducing Open Path (OP) rules that are constrained existential rules. These OP rules generate relevant queries for knowledge graph completion and can produce instantiations that cannot be inferred by closed path rules. Our objective is to mine a knowledge graph for high-quality OP rules about specific target predicates in the head. Techniques such as rule learning and co-occurrence fitness functions are used to achieve this goal, ensuring efficient mining of high-accuracy Open Path rules from massive knowledge graphs.",
    "In recent years, representation learning methods have been developed to model Knowledge Graphs (KG). These techniques or algorithms used to learn a representation of entities or concepts that captures their semantic meaning. The embedding representation has a broader term Embeddings(). Furthermore, rules and predicates are essential components in the rule-based knowledge graph completion framework. Specifically, OPRL is designed to learn Open Path rules about P in the head from public Knowledge Graphs. Moreover, AKGC task involves generating queries of the form P(?, e') and P(e, ?) for entities e and e' occurring in the KG, given a predicate P. Our proposed method utilizes rule-based link predictor and OPSC/OPHC evaluation metrics to assess the quality of Open Path rules mined by OPRL.",
    "The proposed system learns Open Path (OP) rules to generate relevant queries for knowledge graph completion. The OP rule, a constrained existential rule, generates instantiations that cannot be inferred by closed path rules. To evaluate the quality of these rules, we use an open path fitness function that computes the product of predicate embeddings along the path, anchored to entities satisfying free variables at endpoints. Our approach is novel in its ability to generate highly relevant queries for knowledge graph completion, even when there are no patterns or closed rules that fully instantiate missing facts.",
    "In knowledge graph completion, Representation Learning for KG Completion plays a crucial role. Techniques such as embedding entities and predicates into latent spaces can be used to predict new facts. For instance, OPRL algorithm learns open-path rules that generate relevant queries for missing links in an enterprise KG. The process of computing OPSC and OPHC involves evaluating the quality of these rules using their embedding representations. Moreover, Closed rules are used to answer unclear-origin queries, while link prediction models like RLvLR can predict relationships between entities. Furthermore, methods such as Add IncPathFinding(K', P_t, P, A, k, R') extend existing OP rules by appending new body predicates and learning short rules for rightmost predicates.",
    "In this study, we proposed an innovative approach to active knowledge graph completion using rule learning methods for KGs. Our work built upon traditional link prediction systems and introduced a novel algorithmic method for computing OPSC and OPHC measures. We demonstrated that our proposed method can efficiently complete very large KGs by generating relevant queries that predict missing facts, which are essential for human- curated maintenance on an enterprise KG. Furthermore, we showed that our approach can effectively eliminate redundancy in the set of mined rules using a novel algorithmic procedure. Our findings highlight the potential benefits of integrating rule learning methods with traditional link prediction systems to improve knowledge graph completion and curation.",
    "In the realm of knowledge graph completion, ScaleKB and AGKGC are systems or tools that learn closed-path rules to complete missing facts. These rules can be triggered by entities with higher probabilities within a Knowledge Graph (KG). The quality of these rules can be evaluated using efficient methods like OPRL, which computes rule quality through matrix and vector operations. By leveraging high-performing rules and embedding representations, we can find all KG facts that can trigger candidate rules. Furthermore, techniques for building knowledge graphs involve constructing reduced KGs from public Knowledge Graphs, while existential rules govern the existence of entities within a rule-based knowledge graph.",
    "Our proposed method, OPRL (Open Path Rule Learner), learns Open Path rules constrained existential rules. It uses RESCAL to learn representations of entities and relationships. A novel fitness function estimates the quality of an OP rule based on its embedding representation. We go beyond link prediction by inferring relevant queries for missing links using Active KGC. The state-of-the-art rule-based link predictor, RLvLR, generates queries soliciting missing facts in Knowledge Graphs. Our experiments demonstrate that our approach can efficiently compute measures and complete knowledge graphs.",
    "Our proposed method, P_{{t}}({{e1}}, {{e2}}), learns constrained existential rules from knowledge graphs to complete missing facts. These open path (OP) rules generate queries about predicate P and entities in the KG. Our experiments demonstrate that OPSC, a measure quantifying how frequently an OP rule is true, can be used as a fitness function for learning these rules. The complexity of the learning phase must be manageable to efficiently mine high-quality rules from large-scale knowledge graphs like Enterprise and public Knowledge Graphs. By leveraging RESCAL's ability to learn vector embeddings for entities and predicates, we can compute various quality metrics, such as OPSC, which measures the proportion of inferred head instances that are also satisfied when the rule body is instantiated within the KG.",
    "In recent years, knowledge graphs (KGs) have become increasingly important for representing complex relationships between entities. Enterprise and public KGs are a type of graph that represents both enterprise-specific knowledge and publicly available information. The satisfying entities in these graphs can be used to complete incomplete KGs by generating relevant queries when there is no closed rule to answer the query or when the correct answer is a missing entity not present in the KG. RESCAL, an embedding algorithm, learns representations of entities and relationships that are larger and simpler than those in more recent embedding-based link predictors such as HOLE. To efficiently evaluate and prune OP rules during learning, we propose a novel hybrid fitness function that outperforms existing methods. Our proposed method reduces the KG size because existing embedding- based methods cannot handle vast KGs.",
    "In this study, we focus on learning open path (OP) rules from knowledge graphs. The OPSC metric assesses the quality of mined open path rules by calculating the ratio of successful instantiations for both body and head parts. Our proposed method, AGKGC, actively generates relevant queries from knowledge graphs to infer missing links, going beyond traditional link prediction. We also introduce a novel algorithm that combines closed rule fitness function (f_ co(.)) and OP rule fitness function (f_op(.)) to efficiently estimate rule quality. Furthermore, we demonstrate the effectiveness of our approach on public Knowledge Graphs such as FB15K SELECTED.",
    "Link prediction and active knowledge graph completion, which complements traditional link prediction by providing questions to complete vast KGs. The OP rules formalism can generate relevant queries for missing facts about extant entities. Techniques such as computing embeddings after learning existential rules from a sample Knowledge Graph are used to adduce queries. In an industrial application of a link prediction model, the query arise in an industrial setting with high-precision and recall. Building methods like Closed rules complete a KG by answering queries of unclear origin, usually derived from a holdback test set in experimental settings. The proposed OP rule formalism is expressive enough to adduce queries yet suitable for scalable embedding-based rule mining systems.",
    "Our proposed method, Open Path Rule Learner (OPRL), addresses problems in traditional knowledge graph completion by introducing constrained existential rules. These OP rules are learned from Knowledge Graphs (KGs) and used to generate relevant queries for missing links. We assess the quality of these rules using a novel fitness function that estimates their quality based on embedding representations of predicates. Our proposed method outperforms baselines in two sets of experiments, demonstrating its effectiveness in completing incomplete KGs.",
    "In this paper, we explore knowledge graph completion and rule learning using OPRL queries. Our approach, IncPathFinding, learns open-path rules about predicate P from a massive KGs. Unlike traditional methods that scale poorly with increasing entity counts, our method scales well by predicting the existence of missing facts even when entities are absent from the KG. We also propose novel fitness functions like f_op to evaluate OP rule quality and demonstrate its effectiveness in learning constrained existential rules for completing knowledge graphs.",
    "RESCAL, an algorithm that learns entity and relationship representations from massive KGs, has been used to evaluate OPRL queries. The performance of these queries relies on a scoring function that assigns scores based on specific criteria. In addition, RESCAL has also been applied in building methods for mining open-path rules from knowledge graphs. Furthermore, our novel heuristic function for mining OP rules can be used as an algorithm to add path-finding capabilities to the existing closed-path rule-based approach. Moreover, active knowledge graph completion techniques have been proposed to dynamically update KGs by actively inferring missing relationships between entities. In industrial applications of link prediction models, queries arise that require ranking entities based on their relations and probabilities in the KG.",
    "Our proposed method, which learns constrained existential rules (Open Path rules) from massive knowledge graphs, outperforms previous rule-based methods. The novel approach initializes a set of entities by considering the number of entities involved in a target predicate and then generates OP rules using embeddings-based fitness function. In contrast to state-of-the-art rule-based link predictor RLvLR, our method can generate queries that are more relevant to the knowledge graph. Furthermore, we demonstrate the effectiveness of Open Path Fitness Function in evaluating candidate rules. The reduced KG, K', obtained by sampling entities related to a target predicate and including only links between these entities, is used for computing OPSC and OPHC measures. Our proposed method can be applied to public Knowledge Graphs such as YAGO2 core and Poker.",
    "In this study, we propose OPRL-learned rules for knowledge graph completion. Our approach leverages a high-performing link-predicting model built on top of YAGO2, a large-scale rule-based knowledge graph database. The proposed method combines both closed path and open path fitness functions to efficiently estimate the quality of candidate rules. Furthermore, we demonstrate that our generated queries may be valid but there is no answer in the test set, highlighting the importance of active knowledge graph completion using OPRL-learned rules.",
    "To rapidly estimate a rule's quality, we need to find all KG facts that can trigger a candidate rule. Our proposed method uses existential rules and link predictors to generate queries with precision as high as 98% and recall of 62%. The models learned from the knowledge graph are used to predict missing links between entities. We exhaustively generated OP rules for a target predicate P_i and its inverse P_ i^-1 in PathFinding(). Our second set of experiments evaluated the relevance of queries generated by Open Path (OP) rules learned using the OP Rule Learning (OPRL) algorithm.",
    "In order to efficiently compute measures, methods such as OPRL rules can be used. These rules are a type of existential rule that constrain queries for knowledge graph completion by predicting missing entities and facts. For instance, if we have the facts in the KG, open path rules like e_2 can generate queries about predicate P and entities in the knowledge graph. The compositional embeddings represent predicates as weight matrices and use a product calculus for scoring, learned by RESCAL to model Knowledge Graphs (KGs) for tasks such as link prediction, entity resolution, and link-based clustering. Furthermore, building methods like RLvLR* can be used to automatically complete KGs by learning rules that generate relevant queries and predict the existence of missing entities. The top 10% of OP rules mined by this algorithm are ranked based on their quality using a novel embedding- based fitness function.",
    "In the field of knowledge graph completion, our proposed system learns Open Path rules to generate relevant questions automatically and mine quality OP rules from massive knowledge graphs. Unlike traditional rule-based methods that learn closed (non-existential) rules, our approach uses a novel fitness function which can estimate the quality of an OP rule based on the embedding representations of its predicates. This allows us to efficiently evaluate and prune OP rules during learning. Our system is designed to handle vast KGs by reducing their size when necessary. We demonstrate the effectiveness of our proposed system using four benchmark datasets, including FB15K SELECTED (derived from Freebase), YAGO2 core, Wikidata, and a synthetic Poker dataset.",
    "In knowledge graph completion, product calculus and Algorithm 1 are used to generate queries about predicate P and entities. The process of fully automated KG completion involves techniques such as a high-performing link-predicting model built for the Knowledge Graph. OP rules can be used to generate queries that uncover some missing facts in traditional knowledge graphs. Additionally, we introduce a novel, efficient vector computation to formally assess rule quality. Furthermore, CP rules are mined using co-occurrence fitness functions and redundancy elimination methods.",
    "The Active Knowledge Graph Completion (AGKGC) framework uses methods to generate relevant questions about entities and their relations. The process of using Open Path rules learned by OPRL algorithm to generate queries for knowledge graph completion involves generating argument embeddings for subject arguments of P_t and object arguments of P_n, which are then used as input for estimating the quality of open path rules. Our generated queries aim to complete incomplete KGs by predicting missing links between entities. The confidence degree (CD) of a query measures the quantifiable confidence with which an instance of the head with one free variable can be induced from the given knowledge graph. In our experiments, we used multiple public Knowledge Graphs such as Freebase and evaluated the performance of OPRL algorithm for learning Open Path rules and generating relevant queries.",
    "In this paper, we introduce novel algorithmic components for mining Open Path (OP) rules from Knowledge Graphs (KGs). We propose OP rules by computing embeddings representations of predicates and arguments. The link predictors generate queries for knowledge graph completion, which can be used to infer new facts when combined with a link predictor. Our approach shows that there are relevant queries that were not generated even for Poker, highlighting the importance of recall in KG completion. Furthermore, we demonstrate the effectiveness of our method by computing run times in hours, averaged over targets. The open path fitness function estimates rule quality by aggregating pairwise local occurrences of predicate embeddings along a chain of predicates.",
    "The process of knowledge graph completion involves generating queries that can be used to complete incomplete Knowledge Graphs. This task requires learning constrained existential rules, also known as Open Path rules, which can generate relevant queries for KG completion. The quality of these rules can be rapidly estimated using a novel algorithm based on the co-occurrence fitness function. In addition, techniques such as rule-based link prediction and OP rule learning are used to build methods that can complete knowledge graphs efficiently. Furthermore, evaluating the utility of our proposed fitness functions is crucial for assessing their effectiveness in generating high-quality rules.",
    "Knowledge graphs (KGs) are publicly accessible databases that store information on various entities, concepts, and relationships. However, they fail to record relevant entities, as well as relevant relationships for the entities they do record. To address this limitation, a link predictor can be used to generate queries of the form P(?, e') and P(e, ?) for entities e and e' occurring in the KG, given a predicate P. The method involves sampling the KG, computing embeddings of predicates and arguments, generating open-path rules (OPRLs), evaluating their quality using fitness functions, and eliminating redundancy. A novel heuristic function is proposed to mine OPRLs from knowledge graphs. Furthermore, RESCAL learns two sets of embeddings by minimizing a loss function defined over the product of entity and predicate embeddings. The sensitivity of performance for OPRL queries varies with different Open Path Score (OPSC) thresholds. In addition, RLvLR* generates random queries using predicate proportions from the test set.",
    "In order to learn existential rules from knowledge graphs, novel embedding-based heuristic functions can be employed. These methods scale well for automatic completion of knowledge graphs using rule learning. Our proposed method involves a redundancy elimination technique that eliminates duplicate OP rules and ensures no repetition in all extracted knowledge graph completion rules. Furthermore, we propose an open path (OP) rule that generates relevant queries for knowledge graph completion. The quality of this OP rule can be estimated based on the embedding representations of its predicates using a novel fitness function. Additionally, our approach involves active knowledge graph completion to dynamically update the knowledge graph by inferring missing relationships between entities.",
    "In knowledge graphs, missing entities can lead to incomplete information. To address this issue, novel components like Open Path rules and sampling algorithms have been proposed. These methods enable active knowledge graph completion by generating highly relevant queries. For instance, if there exist entities e_1, ..., e_{n-1} in the KG, we can use these techniques to predict missing links or generate all possible queries without considering their relevance to a knowledge graph. In fact, previous rule-based methods have been shown to be less effective than novel components like Open Path rules and sampling algorithms. Moreover, evaluating our system requires comparing it with other systems that are capable of generating relevant questions for query generation. To this end, we use techniques like OPSC and OPHC to compute the quality of these queries.",
    "In knowledge graph completion, rule learning methods for KGs play a crucial role. Techniques such as P_2 and The method are used to build novel approaches like Algorithm 1 that utilize embedding matrix representations of entities. Evaluating OP rules requires metrics like OPsupp, OPHC, and OPSC using matrix and vector operations. IncPathFinding() is an algorithm for generating knowledge through pathfinding and rule extension. We introduce Open Path (OP) rules that are constrained existential rules to address the problem of missing entities in a complete KG. RESCAL learns compositional embeddings representing predicates as weight matrices and uses product calculus for scoring, which can be used for link prediction, entity resolution, and link-based clustering.",
    "The problem of rule-based knowledge graph completion is an issue that requires resolution. In this context, existential rules from knowledge graphs are used to generate queries about missing facts. These rules can be thought of as Open Path (OP) rules, which predict links between entities in a knowledge graph. To evaluate the quality of these OP rules, efficient methods such as matrix and vector operations can be employed. Furthermore, automated link predictors like Algorithm 1 can be built for specific knowledge graphs, such as YAGO2 core, to drive active knowledge graph completion. In this process, latent representations are used to capture intrinsic properties of entities and their relationships, enabling the prediction of missing facts.",
    "In this paper, we present a novel approach to learn open path rules from knowledge graphs. Our method, OPRL, combines both closed rule fitness function and open path rule fitness function to efficiently estimate rule quality. We demonstrate its effectiveness on three different KGs, achieving high scores in terms of OPSC/OPHC metrics. Furthermore, our algorithm can generate relevant queries for missing links, which is particularly useful when there are no closed rules available. This approach has the potential to complete incomplete knowledge graphs and improve their overall performance.",
    "In this paper, we mine OP rules from knowledge graphs (KGs) to generate relevant queries for missing links. Our approach uses a novel method that learns constrained existential rules from KGs and can produce instantiations that cannot be inferred by closed path rules. We demonstrate the usefulness of these mined rules in completing incomplete KGs using RLvLR, which is often used as a benchmark dataset like YAGO2 core. To evaluate our system, we assess its performance on various public Knowledge Graphs (KGs) and show that it outperforms other approaches such as HOLE, perfect link predictor, and CP rules. Our results highlight the importance of considering both entities and predicates in evaluating rule quality.",
    "Our proposed system, which is capable of learning Open Path rules and mining quality OP rules from massive knowledge graphs, has been designed to address the challenge of generating relevant queries even when there is no pattern or rule that fully instantiates the fact in the KG. This method involves sampling the KG, computing embeddings of predicates and arguments, generating OP rules, evaluating their quality using fitness functions, and eliminating redundancy. For example, a pair of entities (e, e') satisfies both the body and head of a CP rule when there is no closed path that fully instantiates the fact in the KG. The system's ability to generate queries even under these conditions makes it particularly useful for knowledge graph completion tasks.",
    "The selected subset of data from Freebase knowledge graph, FB15K SELECTED, represents a traditional type of structured data that organizes relationships between entities. This kind of rule, also known as CP rules, governs behavior and decision-making by defining logical or computational guidelines. Rule learning from a KG is the process of acquiring insights by discovering patterns in data stored within Knowledge Graphs. Techniques such as Active KGC actively generate relevant queries to infer missing links. The quality of these rules can be estimated using functions like f_op that combine co-occurrence and open path fitness metrics. In contrast, traditional knowledge graphs fail to record relevant entities and relationships. To address this issue, novel methods like the sampling algorithm Sampling() reduce the size of a KG by selecting related entities and their connections.",
    "In this context, we have a correct and complete knowledge graph for experiments. YAGO2 induces fewer rules due to its significantly fewer repeatable patterns. Each argument's embedding is obtained by averaging entity embeddings at the endpoints. FB15K SELECTED is a subset of public Knowledge Graphs used for link prediction tasks. Algorithm 1 evaluates candidate open-path rules using OPSC and OPHC metrics, discarding failing ones. The first focuses on entities while the second on predicates in compositional embedding representations. Link predictors like RLvLR are designed to predict missing links between entities. In an industrial setting, human-curated maintenance is necessary for enterprise KGs, which involve their relations. Open-ended questions can be used instead of facts to complete knowledge graphs. Techniques such as rule learning and novel fitness functions help propose missing facts.",
    "In this paper, various methods have been proposed to construct Embeddings for entities and predicates. Our argument embeddings are a set of vector representations obtained by averaging entity embeddings for subject and object arguments of a predicate. The queries could be fed to link predictors to predict links between entities in the knowledge graph (KG). An existing entity already present in the KG has a broader term, 'entity'. Whence does a query arise to drive the link predictor? This is addressed through rule-based link prediction models like those proposed in RLVLR. A knowledge graph (KG) is a pair K = (E, F), where F is a set of facts and E is the set of entities that exist in the facts F. The problem of active KG completion involves identifying missing facts even when there is no pattern that fully instantiates the fact in the KG. Building methods for completing the KG include link predictors like those used in industrial applications. Association rule mining can be applied to discover patterns and relationships between variables by identifying rules with a specified level of correlation.",
    "The AKGC task involves generating queries of the form P(?, e') and P(e, ?) for entities e and e' occurring in a Knowledge Graph (KG), given a predicate P. The process uses techniques such as link prediction to predict unobserved links or relationships between entities. Our proposed method learns rules with free variables from KGs using algorithms like Algorithm 1, which can be used to generate queries soliciting missing facts. We use maximum rule lengths of 4 for PathFinding() and evaluate the quality of open path rules based on metrics such as OPSC/OPHC scores. The query generation task requires aggregating high-performing rules about a target predicate using operators like Noisy-OR, which is not compatible with our aggregation approach.",
    "In this knowledge graph, we can see that OP rules can be used to generate queries. We use embeddings learned by RESCAL for predicates and arguments in the sample KG. The open path fitness function estimates the quality of Open Path rules by computing the product of predicate embeddings along the path, anchored to entities satisfying free variables at endpoints. This approach learns high-quality rules from a knowledge graph, which can be used to predict missing facts even when an entity involved in the missing fact may not exist in the KG. The query arises in industrial applications of link prediction models, where we assess the performance evaluation of Open Path Rule Learner (OPRL) in finding high- quality rules.",
    "In knowledge graph completion, Open Path (OP) rules are used to estimate the quality of a rule by computing the product of predicate embeddings along the path. The OP fitness function estimates this quality based on co-occurrence between entities or open path connections between predicates. Our proposed method uses RESCAL algorithm to embed each entity into a vector and compute argument embeddings for subject and object arguments of a predicate P. This enables us to estimate rule quality using our learnt rule, which is then used as input features for the query generation task. The experiment shows that queries induced from OPRL-mined rules can be relevant and accurate in completing knowledge graphs.",
    "In this study, we propose an innovative approach to knowledge graph completion by leveraging open path rules. Our method represents a traditional knowledge graph as a set of square adjacency matrices and defines a co-occurrence fitness function for mining CP rules. We also introduce a novel algorithmic approach to efficiently compute Open Path Support (OPSC) and Overall Path Hit Count (OPHC). The proposed method is evaluated on YAGO2, a large-scale knowledge graph database, demonstrating its effectiveness in generating highly relevant queries for missing links. Furthermore, we discuss the importance of building methods that can learn rules from massive knowledge graphs with up to 8 million facts.",
    "In knowledge graphs, compositional embeddings learned by RESCAL provide vector representations of entities or concepts. Evaluation metrics such as OPSC and OPHC assess the quality of candidate Open Path rules mined from these graphs. Our argument embeddings are obtained by averaging entity embeddings for subject and object arguments of a predicate, used to estimate rule quality. The state-of-the-art rule-based link predictor, RLvLR, generates relevant queries for knowledge graph completion. A pair of entities forms a closed path or single unbroken loop of links between variables, while the maximum length of rules determines the longest possible sequence of predicates in an Open Path rule. Public Knowledge Graphs like YAGO2 and FB15K SELECTED are widely adopted for link prediction tasks. The authors' synthetic dataset, Poker, is used to evaluate their active knowledge graph completion algorithm.",
    "In recent years, researchers have been exploring various methods for learning rich interactions amongst entities and predicates. One such approach is RESCAL embeddings, which learns two sets of embeddings - vectors {e_i} and matrices {P_k}, by minimizing a loss function defined over the product of entity and predicate embeddings. This method has been shown to be effective in completing knowledge graphs like FB15KSE. Another important task is AKGC, an active knowledge graph completion problem that involves generating queries of the form P(?, e') and P(e, ?) for entities e and e' occurring in a Knowledge Graph (KG), given a predicate P. To efficiently compute measures such as OPSC and OPHC, which are used to evaluate candidate rules, researchers have developed techniques like RLvLR*. These methods can be applied to various domains, including traditional knowledge graphs.",
    "In knowledge graphs, queries soliciting missing facts are crucial for completing incomplete links. The concept of generating such queries arises from the need to predict missing links using link prediction models like Algorithm 1. Large-scale datasets like FB15KSE and YAGO2 provide a foundation for rule mining techniques that can learn existential rules from Knowledge Graphs. Compositional embeddings, as used in RESCAL, enable learning rich interactions amongst entities and predicates. The quality of open path rules is estimated using fitness functions such as Definition 6 or novel methods like RLvLR. Techniques like OPHC measure the proportion of entities that can instantiate the head part of an open path rule.",
    "In this context, we consider open-path rules that are mined from Wikidata. These rules aim to induce relevant queries about missing links in a knowledge graph (KG). The co-occurrence fitness function plays a crucial role in evaluating rule quality by capturing the weight of connections between sequential entities along an open path. Furthermore, representation learning methods and link prediction techniques can be employed to learn entity embeddings that capture their semantic meaning. In this scenario, we have two OP rules mined from Wikidata with their respective Open Path Score (OPSC) and Open Path Head Coverage (OPHC) values. The RESCAL evaluation function is used to estimate rule quality by computing both entity and predicate embeddings.",
    "The query performance of OPRL and RLvLR* as ROC curves in Figure 3 demonstrates the effectiveness of open-path rule learning systems. To address the limitations of existing embedding-based methods, we reduce the KG size because vast knowledge graphs cannot be handled by these approaches. Techniques such as link prediction that predict missing facts about extant entities are crucial for curating tasks. Our proposed method, IncPathFinding(), uses algorithmic techniques to generate open-path rules and evaluate their quality using metrics like OPSC/OPHC scores. By leveraging the structure of knowledge graphs, we can develop more effective rule learning systems, such as Algorithm 1, which enables us to predict missing facts about entities. Furthermore, our approach allows for evaluating link predictors and assessing the performance of various methods.",
    "In the realm of knowledge graphs, Freebase serves as a large-scale database that provides structured information on various topics. Traditional knowledge graphs represent relationships between entities, concepts, and facts in a structured manner. The method for mining open-path rules from these graphs involves sampling the KG, computing embeddings of predicates and arguments, generating OP rules, evaluating their quality using fitness functions, and eliminating redundancy. Massive KGs contain complex relations that require techniques like AGKGC to actively generate relevant queries for knowledge graph completion. Closed rules provide a framework for solving problems, while open-path rules admit instantiations that cannot be instantiations of any CP rule, making them more expressive. The product of predicate embeddings along the path represents latent features of entities connected by chains of predicates. Embeddings are numerical representations of data or concepts in high-dimensional spaces that capture their semantic meaning. Techniques like RESCAL and Representation Learning enable efficient processing and classification. In conclusion, building methods for knowledge graph completion involve leveraging techniques from representation learning to generate relevant queries.",
    "In this knowledge graph, Wikidata has a broader term of rule-based knowledge graphs. M_1 and embedding matrix are related via their properties. Freebase falls under public Knowledge Graphs. An entity involved in missing facts belongs to entities. Open path head coverage of r is connected to attributes (suit and rank). We need to find all KG facts that can trigger candidate rules, which are linked to candidate rules. OPSC has a broader term of Definition 2. Sampled KG relates to their relations. The query arises from an industrial application of link prediction models using link predictors. Entities related to existing entities in the set are connected via any predicates and include e3. Evaluating open path rules is part of evaluation, which assesses quality or performance. Our proposed method uses RLvLR* as a baseline system for comparison purposes. The confidence degree (CD) gives no weight to redundant rules inducing the same query, relating back to rules. And rule-based link predictors are automated link predictors. OPSC has a broader term in Evaluation(). Embeddings() represent mathematical concepts along paths and have a broader term of Algorithm 1. The product of predicate embeddings along the path is connected to Embeddings(). The intended scope of KGs falls under scope, which remains poorly defined.",
    "In knowledge graph completion, Sampling() computes a fragment of the KG (K') consisting of a bounded number of entities related to the target predicate. The co-occurrence fitness function for OP rules estimates rule quality based on the similarity between predicate embeddings. Association rule mining is used to discover patterns and relationships between variables by identifying rules with a specified level of correlation. RESCAL embeddings are compositional-based embedding learners that embed each entity by a vector and each predicate by a matrix, used to learn rich interactions amongst entities and predicates. The support degree of an open path rule r measures the number of pairs (e, e') that satisfy both the body and head of the rule. A link predictor generates relevant queries for knowledge graph completion by learning constrained existential rules. We plan to extend and apply our proposed method OPRL in a setting for human-curated maintenance on an enterprise Knowledge Graph.",
    "In knowledge graph completion, OP represents a notation system or formalism used to represent and manipulate logical expressions. Rules are sets of principles or guidelines used for decision-making, problem-solving, or computational processing. The link predictors answer each query with a sequence of ranked entities. OPsupp is the support measure of an open path rule, defined as the number of entities that can instantiate variables to satisfy both the body and head parts of the rule. Definition 2 refers to standardized concepts used to describe specific ideas, principles, or rules. The subject and object arguments of a predicate P refer to vectors defined by averaging entity embeddings in positions 1 (subject) and 2 (object), respectively, used as input features for rule quality estimation. Queries could be posed to users engaged in curation tasks or web-based question-answering engines. OPSC increases precision. Rule learners learn rules or patterns from data to make predictions. Several directions for future research handle existential rule learning. When the body of each rule is instantiated but there is no fact to fully instantiate the head, a relevant query is induced. A sequence of predicates P1', P2', ..., Pn' refers to paths comprising series of predicates generated for target predicates in knowledge graph completion. Each fact generated by RLvLR has a broader term as queries. Entities that satisfy the second argument of the head refer to entities connected to rule heads through their second argument positions. We introduce novel, efficient vector computations to formally assess rule quality. RESCAL embeddings represent compositional-based embedding learners used to learn rich interactions amongst entities and predicates. The AKGC task is an active knowledge graph completion problem involving generating queries for missing entities not present in the training set. Building methods construct or develop something.",
    "The proposed method, IncPathFinding(), extends existing entities by adding related ones through various predicates. This process involves generating rules from the knowledge graph and then extending these rules to include new entities. The third rule states that if there's a TV program with an occupation, it is likely that the presenter knows someone in that field. Candidate rules are generated based on patterns found in the data. OPsupp measures the support of open-path rules by counting the number of entities that can instantiate variables. Compositional embeddings represent words and concepts as numerical vectors for use in natural language processing. The product of predicate embeddings along a path represents the latent features of connected entities. Active knowledge graph completion dynamically updates missing facts based on existing relationships. Techniques, such as OPRL's algorithm, are used to generate rules from incomplete data.",
    "The proposed system learns Open Path rules to generate relevant questions for knowledge graph completion. It uses a sampling algorithm, Sampling(), which reduces the size of the knowledge graph by selecting entities related to a target predicate and their connections via predicates. The system also employs link predictors that predict missing links between entities in the knowledge graph. Furthermore, it utilizes embeddings learned by RESCAL, which represent entities as numerical vectors capturing their semantic meaning and relationships. By evaluating its performance using OPSC and OPHC metrics, the system can discard failing rules and provide a first solution for actively completing knowledge graphs.",
    "In this knowledge graph, we see various entities and their relationships. An OP rule refers to an open-path rule that connects entities satisfying the subject argument of the head predicate to entities forming the object argument of the tail predicate along a path of entities that satisfy a chain of predicates in the rule. This rule is a principle or guideline governing behavior or decision-making, while F; and 0 otherwise represents a binary matrix representing a Knowledge Graph (KG), where each element A(Pk)[i,j] = 1 if the fact Pk(ei,ej) exists in F; and 0 otherwise. Candidate rules are a set of proposed or potential guidelines, procedures, or decision-making protocols. The mined rules refer to a set of extracted or derived guidelines or principles from data. RESCAL is an algorithm that learns representations of entities and relationships. Techniques used for achieving specific goals or solving problems include sampling algorithms like Sampling(). Our argument embeddings represent the vector representation of subject and object arguments in RLVLR, while each entity's embedding captures its semantic meaning. The quality of rules refers to a measure of how well OPRL finds high-quality Open Path (OP) rules.",
    "The task at hand involves generating queries to complete missing facts in a knowledge graph. This process relies on the concept of embeddings, which represent entities as numerical vectors for capturing their semantic meaning and relationships. A link predictor model can be used to predict links between entities given an initial set of facts. The product of predicate embeddings along a path represents the latent features of connected entities. Rule learning is another approach that involves acquiring knowledge or rules through experience and feedback. Efficient matrix and vector multiplication are crucial for evaluating candidate rules in active knowledge graph completion. Novel fitness functions, such as Definition 7, can be used to measure rule quality based on its properties. The adjacency matrix representation of the KG provides a data structure for representing entities and their relationships.",
    "The set of vector representations, obtained by averaging entity embeddings for subject and object arguments of a predicate, used to estimate rule quality. These argument embeddings are generated from OPRL' rules that connect entities satisfying the subject argument of the head predicate to entities forming the object argument of the tail predicate along a path of entities that satisfy a chain of predicates in the rule. The models learned from these open-path rules can be used for curating tasks including link prediction, which predict missing facts about extant entities. Furthermore, compositional embeddings are employed to represent the product of predicate embeddings along a path, capturing the latent features of entities connected by a chain of predicates.",
    "In knowledge graphs, actively generated questions are used to guide the discovery of unknown facts and entities. Each argument's embedding is a vector obtained by averaging the embeddings of all the entities in the argument position. This concept is used as input for computing quality estimates in rule learning. The state-of-the-art rule-based link predictor, RLvLR, uses compositional embeddings to represent semantic relationships between concepts or entities. OP rules formalism proposes a fragment of the language of existential rules that can be used for scalable embedding-based rule mining systems. Our proposed method learns closed (non-existential) rules and candidate rules by OPSC and OPHC in Evaluate(). The experiment assesses query generation performance on three KGs, including Poker, FB15KSE, YAGO2 core, and others.",
    "In knowledge graphs, measures such as OPSC and open path head coverage of r are used to evaluate rule quality. These metrics are similar to SC and OPSC, which measure the similarity between two rules learned by Open Path (OP) rule learning algorithm, OPRL. The co-occurrence fitness function is a scoring method that estimates the plausibility of an open path rule based on its predicate and entities' embedded representations. Efficient computation methods for these measures are crucial in active knowledge graph completion. Models such as RESCAL embed each entity to a vector using additive calculus, while compositional embeddings represent words or concepts as numerical vectors capturing their semantic meaning. Public Knowledge Graphs store information about various entities, concepts, and relationships.",
    "In a knowledge graph, those with a higher probability are entities that have a higher likelihood of being linked or queried based on their presence and relationships within the knowledge graph. Definition 4 provides an explanation of these concepts. A knowledge graph consisting of entities E and relationships F can be used to predict links between entities using state-of-the-art rule-based link predictors like RLvLR, which is particularly useful for link prediction tasks. The process of predicting unobserved links or relationships between entities in a low-dimensional vector space of latent features not present in the KG vocabulary captures intrinsic properties and relationships between them. Open Path Standard Confidence (OPSC) measures the proportion of entities that can instantiate the head part of an open path rule, while building methods like OPRL generate rules to guide discovery of unknown unknowns and generate relevant queries for knowledge graph completion. The top t% of rules selected based on their fitness values are used as a query generation algorithm.",
    "In knowledge graphs, rules play a crucial role in identifying missing facts and generating relevant questions. A pair of entities satisfying both the body and head of a closed path rule can be seen as an instantiation of such a rule. The top t% of rules refers to the subset of candidate rules selected based on their fitness values. Entity resolution is the process of identifying identical or equivalent records within a dataset, which benefits from the use of unobserved but intrinsic properties of entities and their relations. Our proposed method for rapidly estimating the quality of each candidate rule can be used for early pruning, allowing us to efficiently identify relevant queries for active knowledge graph completion.",
    "The proposed method, OPRL, leverages knowledge graph facts to generate candidate rules for completing missing information. By reducing the KG size due to existing embedding-based methods' limitations on handling vast datasets, we can efficiently learn entity and predicate embeddings using RESCAL. The quality of these learned embeddings is evaluated through metrics such as open path head coverage (OPHC) and link predictors like HOLE. Furthermore, OPRL demonstrates its effectiveness in generating relevant queries for knowledge graph completion by learning constrained existential rules.",
    "Our proposed method, which combines co-occurrence and open path rules to generate relevant questions for knowledge graph completion. The system uses a hybrid fitness function that takes into account both the similarity between entities or predicates connected by a co-occurrence pattern and the quality of candidate solutions in an evolutionary algorithm. To evaluate our system, we use various methods such as Sampling() computes a fragment of the KG (K') consisting of a bounded number of entities related to the target predicate. Our generated queries can be used in combination with link predictors like rule-based link predictor or AGKGC framework to infer new facts. However, decreasing recall as poorer rules get through is an issue that needs to be addressed. The proposed system uses algorithmic approaches such as In IncPathFinding() and argument embeddings for the subject argument of P_t and the object argument of P_n to estimate rule quality.",
    "In knowledge graph completion, RLvLR* does utilize building methods to generate relevant queries. This process involves embedding representations of entities and predicates into a high-dimensional space using RESCAL embeddings. The top candidate rules are then selected based on their fitness values, which can be evaluated using an embedding-based fitness function or novel hybrid fitness functions. These approaches enable the discovery of open-path rules that link entities in a knowledge graph. Furthermore, rule learning systems like CP and Algorithm 1 can learn to predict missing links between entities by leveraging scoring functions over embedded representations. In this context, each argument's embedding is obtained by averaging entity embeddings. The quality of candidate rules can be evaluated using the count of satisfied facts or novel hybrid fitness functions.",
    "The first solution for actively completing knowledge graphs by generating relevant queries that can introduce new entities or predict existing ones. This rule focuses on entities and uses OP rules to generate queries, which are then used as input for an automated link predictor. Techniques such as curating KGs automatically and using compositional embeddings in RLVLR enable massive KGs to be extracted within a reasonable time frame. The query generation task involves generating relevant questions or queries about missing links in the knowledge graph by using open-path rules learned from the graph, which can then be used as input for an oracle or human expert to predict facts.",
    "According to the fitness function, novel fitness functions are used to measure the suitability or 'goodness' of optimization problem rules. The utility of these fitness functions lies in their ability to efficiently estimate and formally assess rule quality. Predicate embeddings play a crucial role in this process by mapping predicates to vectors in high-dimensional space. With satisfying entities, RESCAL embeds each entity e_j to a vector E_j \u2208 R^d, which is used for learning rich interactions amongst entities and predicates. Definition 6 defines the co-occurrence fitness function for OP rules, estimating rule quality by aggregating pairwise local occurrences of predicate embeddings along an open path. The confidence degree (CD) refers to a measure of the maximum OPSC value among all rules inducing a specific query, with no consideration given to redundant rules that induce the same query. A link predictor is used to predict missing links in knowledge graphs, and queries are sets of questions or requests for information. RESCAL evaluation function estimates rule quality by computing both entity and predicate embeddings. The product refers to an OP rule's quality estimation function using both entity and predicate embeddings.",
    "In PathFinding(), we employ Algorithm 1 to tackle problems, which involves finding relevant questions. This process is further refined by summing each row corresponding to each value for the first argument. The OP rules generated from this algorithm are then evaluated using candidate rules by OPSC and OPHC in Evaluate(). These rules can be used to predict links between entities in a knowledge graph (KG), which is represented as a pair K = (E, F) where F is a set of facts and E is the set of entities that exist in the facts. The KG completion process relies on link predictors, such as perfect link predictor, to identify missing facts. Techniques like OPRL rules are used to generate these predictions, which can be further refined using techniques like IncPathFinding().",
    "In this knowledge graph, we can see that P_1 has a broader term of variable. Section 6 formalises new quality notion of query relevance. Missing facts have a broader term of fact and queries are inferred from open path rules for knowledge graph completion. Rule learning systems use algorithms to learn existential rules from knowledge graphs. FB15K SELECTED, which we call FB15KSE, has entities that benefit from the use of unobserved but intrinsic properties of entities and their relations. The state-of-the-art rule-based link predictor RLvLR uses Algorithm 1 for completing incomplete KGs. YAGO2 core is a widely-used knowledge graph dataset used to evaluate various natural language processing models. Embeddings represent words, phrases or concepts as numerical vectors for use in machine learning applications. Traditional link prediction systems rely on techniques such as redundancy elimination methods and latent features. We retain the top 10% of OP rules according to fitness function and changed RLVLR. First, we formalise new quality notion of query relevance using logical rules or vector embeddings.",
    "The use of argument embeddings has significantly improved scalability, allowing for more efficient processing and analysis. This improvement was achieved through a novel algorithm that constructs a fitness function using embedding models. The state-of-the-art rule-based link predictor, RLvLR, has been able to accurately predict missing links in knowledge graphs by leveraging compositional embeddings. Furthermore, the PathFinding method uses rules to navigate through complex relationships between entities and their relations. Representation Learning algorithms have also played a crucial role in generating compact representations of data, enabling efficient processing and analysis. The ability to generate these representations is critical for link prediction models like Algorithm 1.",
    "In knowledge graphs, entities are represented as vectors using embedding models. The product of predicate embeddings along a path represents the latent features of connected entities. Active knowledge graph completion involves dynamically updating missing relationships between entities. Building methods and previous rule-based approaches have been used to learn closed rules in open-path rules. Translation-weakly structured Knowledge Graphs, such as YAGO2, induce fewer rules with weaker performance due to many missing facts.",
    "In a knowledge graph completion approach, entities like 'e_3' and 'entities' are connected by predicates such as 'has a broader term'. Link predictors can generate queries that can be answered from training sets. Embeddings of arguments and each argument's embedding capture semantic relationships between concepts. A rule with 100% HC and SC explains every fact in the KG, while non-zero elements of vectors indicate satisfying entities. OPSC defines confidence scores for open paths. Human experimenters evaluate knowledge graph completion approaches by link prediction questions. The product of predicate embeddings along a path represents latent features of connected entities. Association rule mining discovers patterns between variables using rules with specified correlation levels. RESCAL learns entity and relationship representations to complete the KG. Plausibility is defined as a scoring function over embedded representations, while S_p sets represent subject entities.",
    "In this knowledge graph, we have entities such as S_p and {e | \u2203e' such that P(e, e') \u2208 F}, which represent sets of entities connected by predicates. These entities are related to each other through various predicates like 'contains', 'has a broader term', and 'retain'. For instance, S_p contains the predicate logic expression representing an open path rule for knowledge graph completion. Similarly, {e | \u2203e' such that P(e, e') \u2208 F} has a broader term of Definition, which is used to define an open path rule. The top 10% of OP rules are retained by We, and these rules have been mined using various methods like RESCAL embeddings and HOLE algorithm. Furthermore, the quality of these rules can be estimated using fitness functions like f_op(.) or f_coo(.), which provide a measure of their plausibility based on entity embeddings. Some intriguing challenges remain in this area, including generating relevant queries for knowledge graph completion and developing perfect link predictors that can answer any question with a correct answer when such an answer exists.",
    "The proposed method for link prediction leverages representation learning methods, such as RESCAL, to embed entities and predicates into a low-dimensional vector space. This approach benefits from using unobserved but intrinsic properties of entities and their relations. The algorithm extends sets of entities by adding related entities through various predicates. In the context of curating tasks including link prediction that predict missing facts about extant entities, representation learning methods can be used to learn latent representations that capture semantic meaning. Furthermore, building methods for constructing knowledge graphs like FB15K SELECTED involve creating embeddings and their relations. The performance of OPRL queries is sensitive to the Open Path Score (OPSC) threshold, highlighting the importance of understanding entity relationships in link prediction tasks.",
    "Our proposed method, To compute, learns closed (non-existential) rules from massive KGs in a reasonable time. This rule-based approach enables inference and presents CP rules that govern behavior and decision-making. The process of determining quality measures OPSC and OPHC for candidate rules involves matrix and vector operations. In this context, predicates like P2(z0, z1) are used to reason about concepts and patterns. Furthermore, the co-occurrence fitness function estimates the quality of an open path rule by aggregating pairwise local occurrences based on similarity between predicate embeddings.",
    "In this knowledge graph, Each consists of two parts: a head at the front of the implication arrow and a body at the tail. Rule learning is closely related to coverage, which measures the extent of exposure or comprehension. Figure 1 shows the distribution of mined rules by OPSC and length. The predicates in the KG include P_i and P_t, which are broader terms for Each. Algorithm 1 has been developed as an algorithmic framework for solving specific problems. A system is a computer-based framework designed to perform tasks and operations. Embeddings represent words or concepts as numerical vectors based on their internal structure and composition. The rule- based link predictor uses rules to predict links between entities in the KG, while new facts are added to the graph through the process of representation learning. Queries can be answered by predicting missing links using a link predictor like TuckER. PathFinding is an algorithm that navigates paths through the knowledge graph. Some missing fact can be retrieved by answering relevant questions generated from OP rules.",
    "In knowledge graphs, named predicates or all predicates are used to define relationships between entities. Closed rules and This rule govern behavior or decision-making. The RESCAL algorithm embeds each entity e_j into a vector E_j \u2208 R^d. Our proposed method uses co-occurrence fitness functions to rapidly estimate the quality of candidate OP rules for early pruning. Each consists of two parts: head at the front of the implication arrow and body at the tail, defining relationships between entities. P_1 is a target predicate used to predict missing links in knowledge graphs. A fact is considered missing even when there's evidence for only one entity of the pair, generating questions accordingly. Public Knowledge Graphs store information on various entities, concepts, and relationships. Those entities refer to identifiers for objects such as places or people that exist in facts within a knowledge graph.",
    "The co-occurrences of z_0 as the object argument of P_t and subject argument of P_1, and z_i (1 \u2264 i \u2264 n - 1) as the object argument of P_i and subject argument of P_{i+1} capture the weight of connections between sequential entities along a path. Efficient vector computation is used to process these co-occurrences. Possible queries about this set of facts include {P_1(e_1, ?), P_1(? , e_2), ...}. The novel fitness function estimates rule quality by multiplying predicate embeddings along a chain of predicates in an open-path rule. Various methods have been proposed for constructing latent vector representations of entities and predicates in a knowledge graph.",
    "The concept of missing facts highlights the importance of Representation Learning, which enables us to generate and learn compact representations from data. In this context, specific facts serve as a broader term for missing fact. Furthermore, Wikidata provides a traditional knowledge graph that can be used to compute OPsupp(r), OPHC(r) and OPSC(r). The mined rules in the synthetic Poker dataset demonstrate how fewer rules lead to weaker performance due to repeatable patterns. Additionally, compositional embeddings are built from entity embeddings, which are constructed by aggregating argument embeddings. Overall, these findings underscore the significance of knowledge graphs like Wikidata for generating relevant queries through open path rules.",
    "In knowledge graphs, entities refer to identifiers for objects such as places or people. A mathematical variable or parameter that represents an object can be part of a broader term, which connects it to other entities and relations. The remaining rules are mined from quality rules about all predicates in respective KGs. Compositional embeddings represent words, phrases, or concepts as numerical vectors based on their internal structure and composition. OPRL's performance exceeds Prand on FB15KSE, YAGO2 core, and Poker by factors of approximately 6, 2, and 9, respectively. Argument embeddings in RLVLR refer to vectors obtained by averaging the entity embeddings of all entities occurring as subjects or objects of a predicate P. A state-of-the-art rule-based link predictor, RLvLR, uses compositional embeddings to predict links between entities. Prand queries are generated by first selecting a bag of predicates and assigning subject or object entities to them based on their proportions in the test set. Co-occurrence fitness functions evaluate the likelihood of two entities co-occurring or being associated with each other.",
    "The concept of open path head coverage measures the proportion of entities that satisfy the head predicate of an open path rule. This idea can be quantified using support, head coverage, and standard confidence metrics. In knowledge graph completion, a new fact is needed when the answer is not known. The two key phases in representation learning are embedding entities into a latent space and reconstructing the graph based on learned embeddings to predict new facts. Our proposed method uses techniques such as redundancy elimination and KG sampling to generate relevant queries for completing incomplete enterprise and public knowledge graphs.",
    "The sharp anomaly observed in query generation using OPRL highlights the importance of considering incomplete data in FB15KSE. This observation underscores the need for a novel heuristic function that can effectively capture the relationships between entities along an open path rule's path, as captured by averaging entity embeddings. Our proposed method leverages compositional embeddings to represent words and phrases based on their internal structure and composition. By applying this approach to YAGO2, we can better understand the intended scope of KGs, which typically remains poorly defined. Furthermore, our technique enables us to extract candidate rules from a knowledge graph using existential rules, Horn rules, and other logical principles. This novel method has been successfully applied in various domains, including rule mining and CHAI-based models.",
    "In this knowledge graph, we have two sets of embeddings: vectors {e_i} and matrices {P_k}. Existing representation learners compute embeddings for entities. Entities e and e' are variables representing entities occurring in a knowledge graph, used for generating queries of the form P(?, e') and P(e, ?) for active knowledge graph completion. The matrix M_1 is a mathematical object used to represent entity embeddings and predicate embeddings for knowledge graph completion. A low-dimensional vector space of latent, unnamed features not present in the KG vocabulary captures intrinsic properties and relationships between entities and predicates. Probabilistic-based query generators use Algorithm 1 to generate queries about target predicates and their entities. Facts in the KG that are instances of their heads relate to parent concepts as instances. We use a redundancy elimination method to eliminate duplicate rules from mined OP rules, ensuring no repetition in all extracted knowledge graph completion rules. Translation-based embeddings represent predicates as vectors and use an additive calculus for scoring, used in RESCAL to learn entity and predicate embeddings.",
    "In this knowledge graph, we see various entities and their relationships. The hybrid fitness function combines multiple evaluation metrics to determine candidate solutions' suitability. An instantiation of a rule's body refers to an instance or occurrence within a knowledge graph. Vectors representing distinct entities satisfying certain conditions are used for identifying entities that meet specific criteria. A redundancy elimination method ensures no repetition in extracted rules, while link predictors generate relevant questions given correct answers. User-defined parameters control the maximum length and minimum quality scores of generated rules. Each fitness function evaluates rule quality based on co-occurrence or open path connections between predicates. The baseline query generator Prand randomly selects predicates to assign subject and object entities with probabilities proportional to their occurrence as subjects or objects in a test set. Massive knowledge graphs can be extracted within reasonable time using evaluation methods like this one. Results show that the two sets of embeddings, vectors {e_i} and matrices {P_k}, represent compositional structures of entities. The overall rule from the perspective of predicates connects its endpoints to represent quality based on predicate embeddings along a path.",
    "Our proposed method, which utilizes compositional embeddings and rule-based link prediction, can handle vast knowledge graphs. It initializes a set of entities by considering those involved in the target predicate. The algorithm then employs techniques such as Sampling() to compute fragments of the graph. By doing so, it enables us to calculate metrics like OPHC, measuring the proportion of entities that instantiate head parts of open path rules. Furthermore, our method can predict links between entities and even handle industrial applications of link prediction models.",
    "In this knowledge graph, entities are represented as subject and object arguments. The Sampling() algorithm computes a fragment of the KG consisting of bounded number of entities related to target predicate. If rules instantiated by these entities hold true in the KG, then OPsupp(r) measures their support degree. Facts in the KG provide evidence for or against certain conditions. Some intriguing challenges remain unsolved, requiring novel hybrid fitness functions and algorithms like TuckER. The sampling algorithm reduces data size while preserving relationships between entities. Runtime for mining is crucial to evaluate these techniques. In some cases, correct answers may be missing entities not present in the KG. Definition of predicate embeddings maps predicates to vectors, capturing their semantic meaning. Each argument's embedding represents its characteristics. For entity representations, we use averaging entity embeddings from RLVLR. Rules with free variables allow for more flexible knowledge graph completion. Finally, TV programs with participants and occupations can be used to infer presenter identities.",
    "In this paper, we introduce a novel approach to active knowledge graph completion. Our method uses translation-based embeddings and logical rules to predict missing links between entities. We also propose a data-first approach that prioritizes the addition of information to Knowledge Graphs in an arbitrary manner. Furthermore, our argument embeddings are used to estimate rule quality. The proposed algorithm is compared to existing representation learners such as RESCAL and TuckER. Our first solution actively completes knowledge graphs by generating relevant queries that can introduce new entities or predict existing ones.",
    "In knowledge graphs, link prediction plays a crucial role in predicting missing links or relationships between entities. Methods such as representation learning and embedding representations are used to learn these connections. For instance, P_1 can be located within Freebase's vast repository of their relations. This way, we can generate relevant queries using probabilistic-based query generators. The confidence degree (CD) is defined as the maximum OPSC of all rules inducing a query. To compute this CD, algorithms like HOLE and state-of-the-art rule- based link predictors are employed. Public Knowledge Graphs provide a vast repository of entities, which can be mined to generate queries about missing links. The runtime for mining these graphs depends on factors such as the maximum length of target rules and the number of times an instance is repeated.",
    "In this context, we formally define the confidence degree (CD) of a query q as follows: for queries that can induce q from the given knowledge graph. The CD measures the relevance and quality based on the maximum OPSC of all rules inducing that query. We use RESCAL to learn entity embeddings and predicate embeddings. Adding e3 if we have some P_i(e3, e1) as a fact extends the set of entities in the reduced knowledge graph by adding new entities related to existing ones via any predicates. The quality of open path rules is estimated using either co-occurrence-based fitness function or open-path-based fitness function over the other. Entity embeddings are used alone without incorporating predicate embeddings, and translation-based embeddings represent predicates as vectors for scoring.",
    "Our proposed method, which combines link prediction model and algorithm, utilizes co-occurrence to predict relationships between entities. RESCAL embeds each entity e_j into a vector E_j \u2208 R^d for representation learning. The evaluation method discards failing rules based on OPSC and OPHC metrics. Our system can answer questions by generating relevant queries from the knowledge graph. It also learns predicate embeddings, which are used to predict links between entities satisfying subject arguments of head predicates. Furthermore, our proposed method uses embedding models to complete tasks automatically.",
    "The CHAI system uses Algorithm 1 to filter and prioritize information based on probability. This approach relies on entity embeddings, which are numerical representations of entities or concepts. The authors outline several directions for future research to handle existential rule learning, including using OP rules with embedding matrices. These rules can be used to predict links between entities in a knowledge graph (KG). For example, an OP rule of the form (2) extends existing rules by appending new bodies. Techniques such as sampling and evaluating models like HOLE are also crucial for handling unknowns and generating relevant queries.",
    "In this knowledge graph, we observe that pairs of entities (e, e') satisfy the body of open path rules r. These relations are crucial for understanding how these rules work and what they mean. For instance, OP rules admit instantiations that cannot be instantiations of any CP rule, which highlights the importance of considering both closed and open paths when evaluating rule quality. Furthermore, our proposed method uses translation-based embeddings to represent predicates as vectors and score them using an additive calculus. This approach has been shown to improve the explanatory power of rules by measuring head coverage (HC) and SC. Moreover, we have developed a novel algorithm called PathFinding() that efficiently estimates and formally assesses rule quality according to our hybrid fitness function.",
    "In knowledge graphs, open-ended questions can be used to complete missing entities or relationships. A specific target predicate serves as the head of an Open Path rule being mined from a graph. Embeddings represent mathematical concepts or logical operators that define relationships between entities. Queries soliciting missing facts request information about absent entities in a graph, which can then be used for completion. The set of entities obtained after applying rules to a knowledge graph forms the reduced Knowledge Graph K'. RESCAL embeds each entity e_j into a vector E_j \u2208 R^d. Each non-zero element of this vector indicates a satisfying entity, and the number of distinct entities is given by counting the number of non-zero elements in v(1)(B). YAGO2 induces fewer rules and has much weaker performance because it has significantly fewer repeatable patterns. RLvLR with Noisy-OR combines reinforcement learning and logical reasoning techniques with noisy-or inference mechanisms.",
    "In a knowledge graph, entities such as K and sequential entities are connected by paths like P1, P2, ..., Pm. These connections can be quantified using measures support, head coverage, and standard confidence. To predict missing links between these entities, link predictors like RLvLR* use algorithms like Algorithm 1 to generate queries based on entity embeddings. The quality of these predictions is evaluated by comparing them with the hold-out test data. In addition, rules can be defined to explain every fact in the KG that instantiates its head and is redundant with respect to the graph. Furthermore, probabilistic baselines are used as a reference point for evaluating link prediction models. Finally, industrial applications of these techniques have been developed to predict missing links between entities.",
    "In this knowledge graph, we see various entities and their relationships. For instance, 'o_e' has a broader term of 'variable', while 'Poker' has a broader term of 'algorithm'. The pair '(E,F)' represents a knowledge graph with an entity E and its corresponding feature or attribute F. We are concerned with asking relevant questions about missing links in the graph, which can be used for active knowledge graph completion. Our proposed method uses embedding models to predict these links, making it convenient to generate queries that uncover new facts.",
    "In this knowledge graph, entities such as {A(Pk) : k \u2208 {1,...,m}} and its embedding matrix are related to each other through various predicates. The entity embeddings of e_j and compositional embeddings play a crucial role in capturing the semantic meaning of these entities. Algorithms like Co-occurrence Fitness Function and efficient vector computation help evaluate the quality of open path rules. Our proposed method uses techniques such as IncPathFinding() to generate knowledge graphs. Queries about target predicates, such as P_1(?, ?), are generated by selecting a bag of predicates or using closed path (CP) rules like those used in RLVLR and ScaleKB. The relevancy of these queries is evaluated based on their relationship with missing facts in the graph.",
    "In industrial applications, knowledge graphs (KGs) are used to represent complex relationships between entities. A high-performing link-predicting model built for a KG can be applied to various domains, including poker games. The rule citizenOf infers citizenship of an individual based on their place of residence and location. Rules to generate relevant questions automatically are essential in knowledge graph completion systems. Our proposed method uses compositional embeddings to represent entities' characteristics or attributes. We conducted an experiment that assessed the utility of our fitness functions, which is crucial for learning Open Path rules. The number of possible rules increases exponentially with rule length, affecting the system's running time. Evaluation methods like OPSC and OPHC are used to assess the quality of candidate rules. In conclusion, knowledge graphs have numerous applications in various domains, including industrial settings.",
    "In this knowledge graph, we see various entities and their relationships. For instance, an element of a matrix representing whether a fact is present or not (A(Pk)[i,j]) has a broader term 'embedding matrix'. Similarly, embeddings are represented as mathematical objects that capture complex relationships between entities. Link predictors, which can be automated link predictors, generate queries by selecting a bag of predicates and assigning subject or object entities to them based on their proportions in the test set. The concept of missing facts is also present, where even when there's evidence for only one entity of the pair, a question is generated accordingly. Target rules govern specific behavior or actions, while training data provides examples used for learning models. In this context, vectors are mathematical representations of entities or concepts that can be analyzed to understand relationships between them.",
    "In knowledge graph completion, predicate logic expressions are used to define open path rules. These rules can be evaluated using scoring functions that consider the embedded representations of entities and predicates. A novel method for estimating rule quality involves combining co-occurrence and open path fitness functions. Synthetic Poker is a dataset used to test link prediction models like TuckER. The performance of YAGO2 on OPRL query generation may be affected by its weaker structure or higher number of missing facts. Our proposed algorithm uses building methods, such as the sampling algorithm Sampling(), to construct knowledge graphs and reduce redundancy using elimination methods.",
    "In knowledge graph completion, link prediction plays a crucial role. Evaluation of these predictions involves assessing their quality and performance. The process of predicting unobserved links or relationships between entities relies on open path rules, which are defined by predicates like P_t(e', e). These predicates represent connections between entities in the matrix | 0 2 1 |, where each entity is an An entity e. Rules such as OPsupp (and so high OPSC and OPHC) measure support for these predictions. Our proposed method, PathFinding, uses methods that embed predicates into vectors to filter facts before supplying them to a link predictor like CHAI. This approach enables the estimation of rule quality using the open path fitness function.",
    "In knowledge graph completion, two matrices M_1 and M_2 are used as part of the similarity function sim defined by the Frobenius norm. Each entity has a broader term that refers to individual elements or instances. The results summarize Table 3 showing that a hybrid fitness function combining f_co(.)) and f_op(.)) is capable of mining more quality rules than either of these functions individually. Parameters, such as max rule length l, MinOPSC and MinOPHC, control the maximum length of open path rules and their minimum quality scores for OPSC (open path score) and OPHC (open path head coverage). Pairs of entities representing logical expressions or mathematical notation in a knowledge graph are used to compute embeddings. A link predictor predicts missing links between entities given a query or set of queries. Genuinely missing facts will be treated as false instead of true, which incorrectly penalizes precision and recall metrics. We translate each fact generated by RLvLR into an OP rule learned by the OPRL algorithm that can answer with a missing entity not present in the training set.",
    "The process of inferring queries from open path rules involves combining inference with confidence, widely used in association rule mining. This hybrid fitness function combines multiple evaluation metrics to determine the suitability of candidate solutions. The quality OPSC and OPHC scores are conditions that govern the generation of high-quality Open Path (OP) rules. Vectors represent mathematical concepts or entities' characteristics, while entity embeddings combine these vectors with matrices P_k. Arbitrary queries can be generated using a system like Prand, which randomly selects predicates from the test set. The baseline query generator Prand uses algorithms to assign subject and object entities based on their occurrence as subjects or objects of any predicate in the test set. Inference modules use rules to predict links between entities, such as those represented by TuckER, a type of embedding-based link predictor.",
    "In knowledge graphs, Closed Path (CP) rules and Open Path (OP) rules are used to represent relationships between entities. A CP rule consists of a head and body that form a single unbroken loop of links between variables. In contrast, an OP rule is a constrained existential rule with a more linear shape than CP rules. Link prediction models like RESCAL and TuckER can be applied to industrial applications such as query generation. The proposed system uses methods for automatic completion to generate relevant questions. A potential missing fact in the knowledge graph may require further investigation using open path rules. Our proposed method combines translation-based embeddings and compositional embeddings to find paths between entities.",
    "In an industrial application of a link prediction model, a novel method to rapidly estimate the quality of each candidate rule for early pruning was proposed. This approach leverages techniques such as Co-occurrence Fitness Function and hybrid fitness function to evaluate the suitability of potential links between entities in a knowledge graph. The goal is to generate queries that can be used to complete missing links, which are often provided by human experimenters. A perfect link predictor would accurately answer any given question with one correct answer when such an answer exists. In practice, this may involve using embedding vectors and sampling algorithms to reduce the complexity of the knowledge graph. The third rule learned from a modified leading-edge link predictor states that if there is a TV program with a participant having an occupation, it is likely that the presenter of the program is known.",
    "In the context of open-path rule learning, various methods have been proposed to construct latent vector representations of entities and predicates. For instance, translation-based embeddings represent predicates as vectors and use an additive calculus for scoring, used in RESCAL to learn entity and predicate embeddings. Additionally, probabilistic- based query generators can be employed to generate queries that are related to the existing entities in a set. Furthermore, learning and operating on latent representations benefits from the use of unobserved but intrinsic properties of entities and their relations. Moreover, redundancy elimination methods can be used to remove duplicate or unnecessary information from a set of rules, ensuring uniqueness and reducing redundancy.",
    "In knowledge graph completion, The open path support plays a crucial role. Parameters define the settings for this process. The quality of each candidate rule is evaluated to determine its effectiveness. RDF triples represent facts and relationships between entities. We compare OPRL queries with their answers in test sets. PathFinding() determines optimal paths using techniques like IncPathFinding(). Learning from latent representations benefits from intrinsic properties, as seen in FB15KSE datasets. Measures support rule learning, while CHAI filters facts for link prediction. The fact Pk(ei, ej) represents a predicate between entities. Paths connect pairs of entities, and embedding matrices capture complex relationships. Probabilistic-based query generators create relevant queries. Early explorations published articles on this topic.",
    "The OPSC threshold used to filter out Open Path rules learned by Algorithm 1. The quality of these candidate rules depends on the similarity function and vector multiplication, which are both part of the algorithm's method for evaluating rule quality according to the fitness function. As more missing facts are found, increasing precision is achieved through link prediction using RLvLR*. This process involves building methods that generate queries by translating each fact into two queries, freeing subject and object entities respectively. The utility of our proposed method lies in its ability to learn from these Open Path rules and improve the average precision over time.",
    "Here is the output:\n\n```\n{\n  \"paragraph\": \"In this knowledge graph, we observe that P_1(x, z0) implies P2(z0, z1), indicating a logical relationship between these predicates. The rule body has a broader term of pattern, suggesting a predefined structure used to identify and instantiate facts or relationships within the graph. An industrial application of link prediction model is linked to its broader term, which is itself a link prediction model. Definition 1 satisfies (E,F) in terms of entity representations. E_j \\u2208 R^d and each predicate P_i to a 2D array P_i \\u2208 R^(d\\u00d7d) has a broader term this vector, representing the embedding space for entities. Derived from closed path forms Definition 2 is related to its own definition. Then, for half of instances of each predicate, we have predicates as their broader terms. It is closely related to confidence widely used in association rule mining and Our proposed method shares similar concepts. CD :=\" max(OPSC(r)) represents a measure of plausibility scores. ? has a broader term variable, representing possible queries about target entities. {e_i} has a broader term vectors, capturing semantic relationships between entities. e_j has a broader term embedding, mapping predicates to vector representations. Similar entities are connected by predicate pairs in the graph, exhibiting latent-features and shared characteristics. E3 is an entity related to existing ones via any predicate and added to the reduced knowledge graph K'. The head of r satisfies (E,F) in terms of existential rules. An instance of rule body such as P_1(e, e_1), P_2(e_1, e_2), ..., P_n(e_{n-1}, e') has a broader term instances, representing specific examples or inductions from the graph.\"\n}\n```",
    "The CHAI system uses computational methods to filter and prioritize information based on probability. It has a broader term of algorithm, which represents a step-by-step procedure for solving a problem or accomplishing a specific task. The P_1 predicate relates entities e_9 and e_7, with the object argument being an entity that can be inferred by satisfying its body. Rule mining is a technique used to discover patterns or relationships from data, represented as predicates in compositional embeddings. Our proposed method uses embedding models to generate queries about missing links in knowledge graphs. The new quality notion of query relevance measures the explanatory power of rules and represents a novel approach to measuring query relevance. For example, by applying logical operators like citizenOf(x, y) \u2192 livesIn(x, z) \u2227 locatedIn(z, y), we can infer new facts from existing ones. TuckER is an embedding-based link predictor that uses compositional embeddings to represent predicates. HC measures quantify the explanatory power of rules and are used as a quality notion for query relevance.",
    "The state-of-the-art rule-based link predictor, RLvLR, has been developed to automate link prediction between entities. This approach builds upon existing methods and techniques for learning rules from knowledge graphs. The increasing length of these rules can be attributed to the growing complexity of relationships between entities. Our proposed method, Sampling(), is a novel approach that uses additive calculus for scoring predicates as vectors. In addition, we have also explored other approaches such as IncPathFinding() and building methods like P_1( e_8, ?). Furthermore, our work has been derived from the Freebase dataset, specifically FB15K SELECTED (which we call FB15KSE), which provides a comprehensive knowledge graph for link prediction. Overall, this research aims to improve rule learning by leveraging these techniques and exploring new approaches.",
    "In a knowledge graph, predicates define relationships between entities. The target predicate in the head, P, has broader terms that include all predicates. Non-zero elements of v(2)(P1) also have broader terms as this vector. HOLE methods embed predicates into vectors and are used for predicting links. Some erroneous facts can be corrected by using rules to identify relationships between entities. Relevant questions can be posed to an oracle or human expert to complete the knowledge graph. The object argument of P_n represents a set of distinct entities that satisfy its second argument position. Rules govern behavior and decision-making, while queries are used to retrieve specific information from the graph. Embedding matrices represent entity characteristics, and inference modules derive conclusions based on given data.",
    "In knowledge graphs, entities such as Sam are related to other entities through predicates like 'has a broader term'. For instance, entity embeddings and existential rule learning can be seen as having a broader term of 'entity', which refers to an identifier for an object. Similarly, topics encompass various themes and areas of inquiry that relate to existentially learned rules. Definition 2 provides a standardized concept or notation used to describe specific ideas, principles, or rules. The former fitness function estimates rule quality by using entity embeddings alone, without incorporating predicate embeddings. We evaluate OPRL as part of the evaluation process for assessing rule quality. In addition, probabilistic baselines and algorithms like pairwise multiplication are employed in knowledge graph completion tasks. Furthermore, queries can be generated from open path rules about target predicates, which relate to entities and their descriptions.",
    "In a knowledge graph, entities such as 'x' and 'parameters' are connected by predicates like 'has a broader term'. These relationships can be used to generate embeddings for concepts like 'automatic completion', which relies on methods like 'PathFinding' to navigate through paths. The quality of these embeddings is evaluated using metrics like the RESCAL evaluation function, which takes into account latent features and co-occurrence patterns. By combining these techniques with a scoring function, we can optimize our algorithm's performance in predicting links between entities.",
    "Our system, which is based on a methodology or framework for processing and analyzing data, uses entity embeddings to represent entities e and e'. These representations are used to define facts as scoring functions over embedded representations of predicates and entities. The embedding matrix P, also called a weight matrix, plays a crucial role in this process. Representation learning methods, such as link prediction, are employed to predict missing links between entities. Algorithm 1 is used for evaluation purposes. Furthermore, rule-based link predictors can be applied using mined rules. In the future, we plan to use these techniques to generate queries and evaluate their performance on Wikidata's knowledge graph.",
    "In knowledge graphs, open-path rules (OP) connect entities through shared predicates. The head and body of an OP rule represent the two parts that link entities along a path. Rule learning systems employ a language to express these rules, which can be evaluated using automated link predictors. Our proposed method uses translation-based embeddings to learn entity and predicate representations. We demonstrate how our approach can induce queries from facts and OP rules, with coverage measured by counting the number of induced queries.",
    "In knowledge graph representation, entities such as mathematical matrices and vectors are used to capture complex relationships. Link prediction techniques have been proposed to construct embeddings of these entities. For instance, RESCAL embeds each entity e_j to a vector E_j \u2208 R^d. Various methods have been suggested for constructing embeddings, including translation-based and compositional approaches. These representations can be used in link predictors or other software tools that predict links between entities. The process of representation learning is crucial for capturing the relationships between entities in knowledge graphs.",
    "The initial set of facts aims to filter information, which conventionally generates two relevant queries about presidentOf and Obama. The vector size is set to 100 for knowledge graph embedding. An entity x can be an instance of entities, while a fitness function serves as an algorithm. A novel method rapidly estimates the quality of each candidate rule for early pruning. Simulations are used in building methods, such as redundancy elimination. Facts in the KG include livesIn and locatedIn relationships between Bronte and Canberra. Our proposed method uses predicates as weight matrices to learn entity embeddings.",
    "The concept of about that predicate has a broader term, predicates. Similarly, stars have a broader term, pattern, and rule learning has a broader term, building methods. The reader, likely an expert or developer working on knowledge graph completion and active learning settings, can relate to the idea of increasing precision as more missing facts are found. Public Knowledge Graphs provide definitions for various entities, including similar entities that have a broader term, entities. Techniques such as PathFinding and Various methods can be used to construct latent vector representations of entities and predicates in a knowledge graph. The state-of-the-art rule-based link predictor, RLvLR, uses Co-occurrence Fitness Function to evaluate the quality of rules. Link prediction is an important problem that requires solving unobserved links or relationships between entities. Target predicate in the head, P, can be represented as variable embeddings for efficient computation of plausibility scores. We evaluate OPRL using Evaluation() and consider predicate embeddings as a mathematical representation that maps predicates to vectors in a high- dimensional space.",
    "In knowledge graphs, entities are connected by predicates that describe their relationships. For example, a user engaged in curating tasks or interacting with web question-answering engines can generate queries about various topics, such as learning methods and confidence measures. The confidence degree of a query is the maximum OPSC of all rules inducing it. Similarly, link predictors are used to predict links between entities based on their embeddings. In this context, similar concepts refer to analogous relationships between entities in open path rules. Techniques like aggregation and evaluation functions are employed to quantify these ideas.",
    "In this knowledge graph, we have entities such as SC, which measures frequency or proportion of true instances. We also have variables that represent measurable quantities or abstract concepts. The entity 'citizenOf( x, y) livesIn(x, z)^locatedIn(z, y)' describes an individual's citizenship and residence information. Additionally, there are logical rules governing the behavior and decision-making process. Furthermore, we have vectors as mathematical representations of entities or concepts used to analyze relationships between them. The entity 'K' represents a mathematical concept or value describing a quantity. We also recall measures support, head coverage, and standard confidence that are used in some major approaches to rule learning. Moreover, there is the novel heuristic function which uses predefined rules to solve problems or make decisions. Finally, we have several directions for future research to handle existential rule learning.",
    "The process of rule mining has its roots in building methods, which involve systematic approaches to constructing or developing something. The quality of these rules can be evaluated using open path standard confidence metrics. Prand queries are generated by selecting a bag of predicates and assigning subject or object entities based on their proportions in the test set. A link predictor is used to predict links between entities given an initial set of facts, while every instantiation of a CP rule involves bringing something into existence through Closed Path rules. Sampling methods can be applied to reduce data, and entity embeddings are mathematical representations of an entity's characteristics or attributes. HOLE algorithms generate predictions based on these embeddings. Techniques such as pairwise multiplication can be used to combine multiple operations in sequence. Evaluation metrics like scoring functions assess the quality of mined open path rules.",
    "Our proposed method, which leverages compositional embeddings and similarity functions like the Frobenius norm, can be used to identify distinct entities. This approach involves sampling from a set of methods, including rule-based link predictors, to generate queries that uncover missing facts in knowledge graphs. By filtering out obsolete rules and low-quality links, we can improve the precision of our predictions. In fact, CHAI filters facts before supplying them to a link predictor, which is an algorithmic approach that has been shown to be effective in evaluating the quality of predicted links. Furthermore, TuckER, an automated link predictor, can outperform queries generated by modified leading-edge link predictors. The average precision of our method is high when evaluated on datasets like YAGO2 core, where we can rank entities (countries) based on their relevance.",
    "In this knowledge graph, we have various entities and relations. The citizenOf relation indicates that an individual has citizenship in a particular country or jurisdiction. A question can be used to uncover some missing fact or information in the knowledge graph. Fitness functions are mathematical concepts used to evaluate or measure the quality of something. Hybrid fitness functions combine multiple evaluation metrics or optimization techniques to determine the suitability of candidate solutions in an evolutionary algorithm. Entities and predicates represent logical relations that map entities to each other, represented as a matrix. Prand queries generate random bags of predicates and assign subject or object entities based on their proportions in the test set. State-of-the-art rule-based link predictors like RLvLR can be used for predicting links between entities. The citizenOf relation is inferred from facts about an individual's city of residence and nation, as described by a OP rule.",
    "The measures used to evaluate head coverage are crucial for understanding how well a model or algorithm covers its target domain. Each predicate P_k has a broader term, and these predicates can be embedded into vectors using various techniques. The quality of each rule learned from a Knowledge Graph is essential in determining the effectiveness of the system. Moreover, methods that embed predicates as weight matrices are useful for capturing rich interactions amongst entities and predicates. In addition, CHAI uses computational methods to filter and prioritize information based on probability. Furthermore, the number of potential rules generated by PathFinding() algorithm can be substantial.",
    "In knowledge graph completion systems, representation learning methods are used to build rules that infer citizenship of an individual based on their place of residence and location. These rules can be complex, involving co-occurrence patterns between entities and predicates. For instance, a rule like 'citizenOf(x, y) \u2192 livesIn(x, z) \u2227 locatedIn(z, y)' infers citizenship from the relationship between an entity's place of residence and its location. The quality of these rules can be evaluated using fitness functions that take into account the embedding representations of their predicates.",
    "The following scoring function is defined to evaluate candidate rules and rapidly discard poor performers. We call this rule-based link predictor RLvLR*. A shared entity in place of z0 refers to an entity that satisfies both subject and object arguments of a predicate, used as a connection point for entities along a path in open-path rules. P1, P2, ..., Pm is a sequence of paths connecting pairs of entities. P2(z0, z1) is a logical rule or predicate that takes two inputs and produces a specific outcome. SC measures the frequency or proportion of true instances in a knowledge graph. Coverage refers to the extent of exposure, protection, or comprehension. Methods are systematic procedures used to achieve a specific goal or solve a problem. An answer is typically returned as a ranked sequence of answers by link predictors. The proposed system uses techniques such as rule-based link prediction and open-path rules to generate relevant questions.",
    "In knowledge graphs, latent-features relationships are statistical patterns observed between predicate pairs. Techniques for automatic completion involve building methods that learn compact representations from data. Rules define logical operators and predicates establish connections between entities. The terms of a rule refer to mathematical representations or concepts embedded as vectors in high-dimensional spaces. Co-occurrence fitness functions estimate the quality of rules, while link predictors predict links between entities. Our proposed method uses RESCAL embeddings for learning entity representations. Experimental settings involve holdback test sets and evaluation metrics assess the performance of knowledge graph completion methods.",
    "In knowledge graphs, translation-based embeddings represent predicates as vectors and use an additive calculus for scoring. Techniques like this are used to achieve specific goals or solve problems. For instance, Open Path rules can be mined from these graphs using link predictors that produce relevant queries. These rules can have entities that satisfy the first argument of the body, which is a set of conditions governing a particular situation. Experimentally, our proposed method has shown promising results in handling existential rule learning and future research directions aim to improve this process. Each entity's embedding vector represents its semantic relationships with other concepts or facts. PathFinding algorithms can be used to determine optimal paths between entities based on their predicates. The results show that a hybrid fitness function combining both f_co(.)) and f_op(.)) is capable of mining more quality rules than either of these functions individually.",
    "The industrial application of link prediction models has led to the development of automated link predictors. In a TV program, if there's a participant with an occupation, it's likely that the presenter is known. The co-occurrences of entities can be used to generate queries about presidentOf and other relations between entities. FB15K SELECTED dataset provides a comprehensive set of facts for training machine learning models. Measures such as support, head coverage, and standard confidence are used in rule learning approaches.",
    "The concept of pairs refers to sets that satisfy specific patterns or rules. TuckER, a type of link predictor, can be seen as having broader terms such as set and predicates. Vectors like |0| are also related to the concept of vectors. Inference is relevant when uncovering missing facts, which may involve using techniques like predicate embeddings. Building methods can lead to asserting erroneous facts if not done correctly. For example, Algorithm 1 uses building methods for evaluation purposes. Query generation tasks often rely on known-missing facts and techniques like Noisy-OR. Entities related to existing entities in a set refer to those involved in target predicates and their inverses. Definition 2 formally defines the computation of query results.",
    "Prand, a baseline query generator, selects predicates and assigns subject or object entities to them by random selection. HC measures quantify the explanatory power of rules, while Techniques refer to methods used to achieve specific goals. Predicates P_1(e_1, e_2), P_1(e_4, e_5) represent relationships between entities. Formally, the CD of a query is defined as follows for queries that can induce facts from given knowledge graphs. Very high precision indicates accurate and relevant results. Some major approaches to rule learning include Techniques. The entities that satisfy the first argument of P_t are identified by finding distinct entities using Methods. Parameters z0 represent placeholders in mathematical expressions, while information fact P_1(e0, e1) is a piece of data represented as an equation. Evaluating link predictors assesses their performance. One unification for each free variable y with variables from the head predicate P_t results in open path rules. The CHAI system It filters facts before supplying them to link predictors. Vector representations E_j embed entities in high-dimensional spaces, while instances of predicates are used by Prand baseline. Matrix P_n represents a mathematical function that takes input and produces output.",
    "The quality rules define acceptable levels of behavior, with This rule being a principle governing decision-making. The set S_p functions as the subject or topic in various contexts, while P represents mathematical relationships between entities. A fact about Obama's presidency and USA illustrates how facts are defined by scoring functions over embedded representations. MarriedTo(x,z) is a predicate defining relationships between entities x and z. Techniques for evaluating plausibility include co-occurrence fitness functions and measures such as open path standard confidence. The authors We adapt these techniques to mine CP rules, using compositional embeddings and building methods like HOLE. Head coverage and standard confidence are used to evaluate the quality of mined rules. For example, an OP rule states that if x lives in z, then citizenOf(x,t) implies livesIn(x,z). Vectors represent entities' characteristics, with embedding matrices capturing complex relationships.",
    "In knowledge graphs, understanding the maximum length of rules and its relation to open path standard confidence can provide valuable insights. The data-first approach plays a crucial role in this context, as it enables automatic completion of tasks without human intervention. Furthermore, entities that satisfy the first argument of the body are essential for evaluating the quality of mined open path rules. Additionally, PathFinding techniques and entity resolution methods help navigate through complex knowledge graphs to identify new facts and information. Overall, these concepts demonstrate how relationships between entities can be leveraged to achieve efficient problem-solving.",
    "In knowledge graphs, entities such as K and P are used to describe mathematical concepts or values. These entities can be related through predicates like 'has a broader term' which indicates that one entity is more general than another. For instance, Definition has a broader term of (1), indicating that the concept of definition encompasses the specific notation (1). Similarly, B has a broader term of matrix, suggesting that matrices are a type of mathematical construct used to describe entities like B. The paragraph also mentions variables x, y, z_1, ..., z_{n-1} which can be instantiated with values from sets like {e_3, e_4, e_5}. Furthermore, the concept of confidence is closely related to It, implying that a measure of certainty or trustworthiness is associated with evaluating rules. The paragraph also touches on unknown unknowns and facts, highlighting the importance of understanding relationships between entities in knowledge graphs.",
    "In this knowledge graph, we see various mathematical concepts and variables representing abstract ideas. A matrix represents a predicate, while experiments involve evaluating hypotheses through controlled trials or observations. The OP rule relates entities via predicates P1(3,1) and P2(0,2). Similar entities are connected by predicate pairs, exhibiting latent-features relationships. Entities that satisfy the first argument of the body can be found in Table 2, which shows average numbers of quality rules mined for all predicates. Wikidata has only 50 randomly selected predicates targeted. The OP rule also relates to relations between entities and matrices.",
    "The proposed system uses techniques such as translation-based embeddings and compositional embeddings to filter facts. It also employs link predictors, which are methods for automatic completion of entities like e_1 or | 0 |. The system evaluates its performance using evaluation metrics, including confidence degrees P(?, e') or q = P(e, ?). Additionally, it uses building methods such as CHAI and O_p to construct a knowledge graph with distinct entities {e_1, e_2, e_3, e_4, e_5}. The system's ability to find unknown unknowns like e_8 is crucial for its success. Furthermore, the proposed system can sum up each row of data to identify unique patterns and relationships between entities.",
    "In this knowledge graph, we explore various relationships between entities. A pair of entities (e', e) represents a logical expression or mathematical notation. Definition and Definition 1 provide concise explanations for understanding these expressions. The confidence degree CD measures the quantifiable confidence in inducing an instance with one free variable. We also consider redundancy elimination methods to remove duplicate information from rules, ensuring uniqueness. Techniques such as translation-based embeddings and compositional embeddings are used to represent entities. For each given fact, we evaluate its plausibility using a scoring function. Our proposed method uses relevant questions generated by us to pose queries about predicate P_1. The set of entities E = {e1, e2, e3} is defined with corresponding facts F. Experimentally, our approach demonstrates the effectiveness of these techniques in completing knowledge graphs.",
    "In this knowledge graph, we see various entities and their relationships. The tail predicate P_n has a broader term of predicates, which are mathematical concepts or logical operators that define relationships between entities. Translation-based embeddings, building methods, and experiments all have broader terms in the realm of predicates. Then, satisfies the pair (E,F), where E is an entity set and F is its corresponding feature or attribute. The matrix | 1 0 0 | has a broader term of sets, which are well-defined collections of unique objects or elements. P_n also has a broader term of predicates, indicating that it's a mathematical function or relation taking one or more input values and producing an output value. Link predictors have a broader term of automated link predictor tools that predict links between entities. MinOPSC and MinOPHC are minimum threshold values for OP rule quality scores. Whence does the query arise is related to queries, which are sets of questions or requests for information. PathFinding() is a computational process determining an optimal path or route. The pairs (e,e') satisfying the body are connected by definitions, illustrating how entities and predicates relate to each other.",
    "The proposed method defines an initial set of facts, which serves as a starting point for learning open path rules. The entities that satisfy the first argument of P_t are identified and used to generate queries about predicate P. This rule has a broader term in the context of confidence widely used in association rule mining. Furthermore, the number of entities is counted using techniques such as held-out facts evaluation method. Additionally, the head entity refers to an open path rule that satisfies certain conditions.",
    "The concept of instantiation can be used to satisfy both premise and conclusion parts of an open path rule. This process, also known as embedding models, allows for the creation of a pair of entities that are connected through specific relations. Techniques such as Prand and TuckER can be employed to generate these embeddings. Additionally, confidence widely used in association rule mining is closely related to this concept. Furthermore, computing involves evaluating facts written in the form P(e, e') which satisfies certain conditions. The second rule states that if a region has a known continent, then its highest point is likely known. This principle can be applied using techniques such as sampling and evaluation.",
    "In knowledge graphs, similar entities are connected by predicate pairs exhibiting latent-feature relationships and shared characteristics. Definition provides a concise explanation or statement of meaning for these entities. The set of entities includes unique identifiers like e, which represents an object, concept, or fact in a framework. HC measures quantify the explanatory power of rules, while building methods construct or develop something systematically. Heuristics are efficient approaches used to achieve specific goals. Predicates define relationships between entities, and parameters specify settings for operations. A pair of entities can be connected by predicates like P1(P2), which takes one or more parameters as input. The set of facts about predicate P_1 includes {P_1(e_1, e_2), P_1(e_4, e_5)} among others. Embeddings represent words, phrases, or concepts as numerical vectors for use in natural language processing and machine learning applications.",
    "In knowledge graphs, entities such as e0 and variable represent unknown values or objects used to score functions. Parameters like MinOPSC define specific settings for these scoring functions. The concept of missing facts from training sets refers to instances where query answers are only present in test data but not the training set. In this context, a hybrid approach combining different methods can be employed to achieve better results. Our proposed method involves evaluating the relevancy of questions and using Max operators to find the maximum value for specific predicates like P. The head and body of rules define relationships between entities, while chains of predicates in these rules represent sets of related predications. Furthermore, mining knowledge graphs for high-quality OP rules about a target predicate can be achieved by setting objectives and applying methods such as citizenOf(Bronte, ?) to identify specific instances.",
    "The mathematical variable or object e0 represents an unknown value used to score functions. It has a broader term, parameters, which define specific settings or conditions. The set of facts about predicate P_1 includes instances such as {P_1(e_1, e_2), P_1(e_4, e_5)} and is related to the variable entity. Another instance is z3, also representing a value or input in an algorithm or program. In addition, there are matrices M_1 and M_2 that have broader terms as matrix entities. The relationships between these entities can be described by their relations, which define connections between them. Furthermore, open access articles provide information on specific topics, while bag of predicates represents a collection of random predicate instances used to generate Prand queries. Algorithmic methods are employed for building and navigating through paths using PathFinding techniques. Entity embeddings capture the meaning of subjects and objects involved in actions or relations.",
    "The OPSC threshold, which represents the quality of rules learned by OPRL algorithm, has a broader term 'setting', indicating its connection to the concept of setting. Similarly, entity e1 can be seen as having a broader term 'entities' due to their relationship with entities. The definition for computing query results is also connected to Definition 4 through predicate P_1 and predicates in general. Furthermore, maximum rule length has a broader term 'parameters', suggesting its connection to the concept of parameters. In addition, citizenOf(x,y) can be seen as having a broader term 'rules' due to their relationship with rules. The optimum obtained by tuning is also connected to results through predicate P_1 and predicates in general.",
    "The vast repository of information contains numerous entities and predicates, with over eight million facts and four million entities. These entities can be categorized into sets, such as {x, z_i, y}, which represents a mathematical concept or variable. The head and body refer to the subject argument of the head predicate P_h(e, e') and the object arguments of subsequent predicates in the rule's path, respectively. Wikidata manages factual information about entities like | 0 |, (1), {x, z_i, y}, set, entity, and others. The relationships between these entities are represented by RDF triples, such as P_1(e_1, e_2) denoting a fact in the knowledge graph.",
    "In this knowledge graph, we have various entities and relationships. The entity 'HC' measures the explanatory power of rules. Given predicate P relates to predicates that define relationships between entities. Two main categories are translation-based embeddings and compositional embeddings used in building methods. CitizenOf(x,y) livesIn(x,z)^locatedIn(z,y) is a rule inferring citizenship based on residence and location. Unknown unknowns refer to unexplored concepts, while e_3 and e_5 represent variables or arguments. With numerical attributes are rules with free variables representing numerical values. Table 3 presents research results, likely containing tabular information. Queries evaluate the quality of queries, whereas evaluation assesses performance. Methods like redundancy elimination method remove duplicate information from a set of rules.",
    "In a knowledge graph, entities such as 'head with one free variable' and 'questions' are related by predicates like 'has a broader term'. For instance, the entity 'e_9' has a broader term of 'arguments', while 'the cardinality of this set' is related to 'cardinality'. Rules like 'citizenOf( x, y) \u2192 livesIn(x, z) \u2227 locatedIn(z, y)' infer citizenship based on place of residence and location. Our proposed method for building methods can obtain optimum parameters by tuning. The spouse's birthplace may be known if the person is known. Extant entities are instances of 'entity', while '{e1,e2,e3}' has a broader term of 'entities'. Mathematical matrices like '| 1 0 0 |' have broader terms in notation forms like '(1)'. Variables e and e' can instantiate z_0, which satisfies both P1(x,z0) and P2(z0,z1) \u2227 P3(z1,y). We get a False Positive Rate of almost 50%. Sets '{e1,e2,e3}' have broader terms in 'set', while Table 3 presents results. An entity involved in the missing fact has a broader term in Definition, which is also applicable to It's general form and Definition 2. Non-zero elements indicate entities that satisfy the first argument of the body.",
    "According to the graph, erroneous facts are a type of information. Questions can be posed to an oracle or human expert for clarification. Figure 3 has a broader term as Figure 1, indicating that it represents a visual representation similar in concept. Entities e_5 and e_3 have a broader term as variable, suggesting they represent mathematical objects used in pathfinding calculations. A is also described as having a broader term of variable, implying it serves as a parameter for such calculations. The subject and object arguments are represented by entities, highlighting the importance of relationships between these concepts. Definition 2 has a broader term as Definition 1, indicating that both definitions serve to describe similar principles or rules. Evaluation methods have a broader term as Methods, suggesting they represent systematic approaches used in problem-solving. In this paper, we could infer queries based on instance facts and predicate P1, which is closely related to confidence widely used in association rule mining. Learning can be achieved through building methods that utilize parameters and unified frameworks for constructing knowledge. Conditions are stipulations governing specific situations, such as finding good rules or inferring queries.",
    "The concept of mathematical functions or variables, as represented by e_1, has a broader term Definition. This definition encompasses various topics and areas of inquiry. The head of this rule, about that predicate, can be linked to entities satisfying its first argument through predicates like P_1, ..., P_n. Techniques such as Noisy-OR are used to predict links between these entities. Building methods like Prand generate queries based on the relationships defined by Definition 2 and other rules. The confidence degree of a query is measured using predictive attributes like suit and rank in card games. In conclusion, this rule defines relations between various concepts, including mathematical functions, predicates, and link predictors.",
    "The scoring function specifies the fact that entities are connected via predicate P1. The object argument of P_n has a broader term, variable. This rule states that if the spouse of a person (z) is known, it is likely that their place of birth is also known. Evaluate() and building methods are used to assess this likelihood. Based on test facts, foundations provide the basis for evaluation. Definition provides the meaning of P, which represents relationships between entities. Experiments evaluate these relationships through controlled trials or observations. A subject (respectively object) entity is assigned by random selection with probability proportional to its proportion as a subject (or object) in any predicate from the test set. The head of a rule governs its behavior and operation, while Table 2 provides data for evaluation. Techniques are used to find distinct entities, which are relevant to target predicates. Sampling() selects entities based on their proportions. Evaluation assesses the quality or value of something. Head coverage (HC) measures the proportion of heads covered by an entity.",
    "The concept of 'This begs the question' relates to queries, which are sets of questions or requests for information. Sampling methods can be used to select a subset of data points from a larger population, as seen in Section 6 where experiments are conducted. A solution is proposed based on results obtained through query evaluation and scalability improvements. Each entity e_i has its own definition, while the authors outline several directions for future research on handling existential rule learning. The entities satisfying the subject argument of the head predicate P_t can be categorized as a set of entities. In this way, methods are used to achieve specific goals or solve problems. Latent-feature relationships exist between predicates in knowledge graphs, where similar entities are often associated with each other. Table 4 presents numerical values summarizing data from an article on query evaluation and test sets.",
    "The concept of not assigning any importance or value to redundant rules that induce the same query, as defined by a broader term 'Definition', serves as an argument for a data-first approach. This approach prioritizes and relies heavily on data as its primary foundation. In this context, entities such as e' and \u211d^d are used to describe relationships between subjects and objects. Each card is described using two attributes (suit and rank), which can be represented by vectors defined respectively as part of a vector space. The existence of missing facts in the test set highlights the importance of recall measures, which quantify the proportion of actual instances that are correctly identified as positive.",
    "The matrix M_2 has a broader term, which is a mathematical construct or data structure consisting of a rectangular array of numbers, symbols, or expressions. The Definition e_j also has a broader term, which represents a vector representation or embedding in a high-dimensional space. Furthermore, the body of the rule and its corresponding rule body both have broader terms that define logical premises or mathematical conditions. Additionally, we can see that certain queries are counted as true if they have instance facts in test data and false otherwise, based on specific conditions. Moreover, entities satisfying subject arguments of head predicates P_t also have a broader term related to predicates. We used our proposed method with 0.98 precision for building methods, which demonstrates the importance of coverage and average precision. In conclusion, these relations highlight the connections between various mathematical concepts, logical operators, and data structures.",
    "The paper presents various techniques for link prediction, including embedding models. The authors evaluate these approaches using experiments and provide a definition of the target predicate P_1, which represents relations between entities. They also discuss universal quantification of all variables and its application to open-path rules. Furthermore, they introduce a shared entity in place of z0 as a connection point for entities along a path. Additionally, they describe sequential entities such as bodies and provide definitions 2 and 5 that clarify the concept of predicates.",
    "The predicate P_h serves as the head or main verb of logical rules. It has a broader term, variable, which represents measurable quantities or abstract concepts. The instantiation process brings entities into existence and can infer queries like citizenOf(Bronte, ?). Predicates such as P_1(e_8, e_7) have instances that satisfy both P1(x, z0) and P2(z0, z1) \u2227 P3(z1, y), where {e_3, e_4, e_5} can instantiate z0. Evaluation methods assess the quality of results, which are often based on plausibility scores calculated from embedded representations.",
    "The concept of scalability plays a crucial role in evaluation, as it enables us to extend our understanding and knowledge. This paper extends early explorations published in specific facts, providing evidence for unknown unknowns. The subject argument of P_t has a broader term variable, which is essential for defining entities that satisfy the first argument of the body. Future work will build upon Our work, summarizing results summarized in Table 3. A reduced deck with 6 ranks and 2 suits can be used to play Poker, but it's important to consider head coverage (HC) when evaluating Definition 1. In a country (), we must define pairwise local fitness functions accordingly.",
    "The occupation of an individual, such as that has an occupation (y), can be described using attributes like suit and rank. This concept relates to a broader term, namely Class attribute. Similarly, Pairwise local fitness functions are defined accordingly, which also falls under Definition 1. An entity e is part of the entities collection, while early explorations build upon Previous work. False answers instead of true ones can be treated as conditions that govern specific situations. Answers provided to problems often rely on attributes like suit and rank or even country (w) information. FB15K SELECTED, which we call FB15KSE, is a dataset derived from Freebase, widely adopted for link prediction. Its proportion as a subject respectively object of any predicate in the test set can be measured using predicates. Each entity has its own attributes, and facts about target predicates like P_1 provide insight into specific situations. Sam, an individual entity, represents one such example. Object arguments satisfy the head of rules, while heuristics are techniques used to achieve a goal or solve a problem.",
    "The concept of variable has a broader term, predictive attributes. A Poker Hand can be seen as having a broader term, poker hand. The suits used to play Poker have a broader term, a reduced deck with 6 ranks and 2 suits. Wikipedia articles are an example of written works that present research or information on specific topics, which in turn have a broader term, article. Object arguments serve as the target of predicates' actions, while entities can be found through building methods. The foundations of understanding something lie in its definition. Unknown unknowns refer to unexplored concepts or ideas. Spouse(z,y) is an example of a predicate that defines a relationship between two variables. This paper outlines its scope and has a broader term, this paper itself. Some entities may be located within regions (z), which have their own location.",
    "The OP rule 'citizenOf(x, t) \u2192 livesIn(x, z)' with instantiated body as 'livesIn(Bronte, Canberra)', which generates the query '? citizenOf(?, ?). The Australian actress Bront\u00eb. A principle or guideline governing behavior or decision-making is applied to entities that satisfy the first argument of P_t. Definition 1 serves as a foundation for understanding or explaining something. Training data includes instances such as 'livesIn(Bronte, Canberra) and locatedIn(Canberra, Australia)', which are used to validate models or algorithms. We ask questions about these facts, considering their scope and relevance. The body of this rule has a broader term in the form of This paper, which presents research on techniques for generating queries from training data.",
    "In the context of rule bodies, conditions serve as the foundation for specifying when rules apply. This concept is closely related to confidence widely used in association rule mining. Vector spaces provide a mathematical construct representing points or objects with specific coordinates and dimensions, which can be applied in Computing. The numerical value 'n' represents an amount or quantity, while variables are values or symbols that represent measurable quantities or abstract concepts. Ranks refer to sets of classifications, such as suit and rank attributes used to describe something. Evaluation methods assess the quality or performance of something with precision measures like 0.98. Predicates define relationships between entities, which can be located within a specific context using predicates like 'locatedIn'. The subject argument serves as the starting point for logical operations or relationships, often defined by definitions like Definition 2. Section 6 contains experimental data and methodology used to investigate hypotheses.",
    "The subject argument has a broader term variable, indicating that it serves as the starting point for logical operations or relationships. In a country (w), locatedIn defines where something exists. The plausibility of a fact refers to its degree of truthfulness. Two predicates convey distinct relationships between entities. P1(e1, e2) and livesIn(x, z) are binary relations that define connections between objects. S_p represents the set of subject or topic entities in a given context. Definition provides concise explanations for these concepts. The presidentOf(Obama, USA) fact highlights Barack Obama's role as head of state. In the absence of any comparative system, we used methods to evaluate and compare different entities. For half of the instances of each predicate, conditions governed their selection. StudiesIn(x, z) indicates educational institutions where individuals study. Those entities refer to identifiers for objects such as places or people that exist in facts within a knowledge graph. The head variables represent values or quantities that serve as heads of logical operations.",
    "The cardinality of entities can be described by numerical values, such as (2). Link predictors and building methods are used to construct or develop something. Evaluation processes assess the quality or performance of these constructions. Occupation(w,y) refers to a person's profession or job, which is related to their place of birth. Classic versions represent earlier forms of information that can be cited with reference numbers like (4). The first rule states that knowing someone's spouse increases the likelihood of knowing their place of birth. Conditions govern this relationship and others in the graph. Occupation(y) represents a person's main activity, which is connected to their relations. Definition statements provide concise explanations for entities like M_2, e1, {e_1,e_2,...}, observation, results, Experimentally, False Positive Rate, placeOfBirth(z,x), head of rule, and measures support.",
    "All experiments are a collection of scientific tests or trials conducted to investigate a hypothesis or test a theory. These experiments have various evaluation methods, which involve techniques used to achieve specific goals. The parameters and suits involved in these experiments can be attributed to individual entities such as Sam, who has an occupation that is connected through the relationship 'livesIn'. Furthermore, there are numerical attributes like 0.50 and s_e, which represent frequencies or counts of occurrences. Additionally, each entity has a definition that describes its nature and distinguishes it from others. There remain some intriguing challenges in understanding these entities' relationships, including their citizenOf status, questions about variables, and the need to define numerical attributes.",
    "The concept of definition serves as a foundation for understanding or explaining something. Instantiation brings this into existence, and variables represent measurable quantities or abstract concepts. Predicates define relationships between entities, such as parentOf(z,y), which establishes a child-parent relationship. Two attributes - suit and rank - characterize each card in a Poker hand. We, a group of individuals working together, can achieve common goals through techniques like instantiating the body of this rule. The optimum result is often the best outcome or value. A region (z) within a country has its highest point and exists as a geographic entity. Subject and object arguments represent relationships between entities, while support measures quantify something's effectiveness. Rule quality evaluates how well an operation operates. Techniques like instantiating the body of this rule can achieve specific goals. In a country (w), nations have their own governments.",
    "The pair of entities 'e1' and 'e2', which are included in a set of entities relevant to a target predicate, has a broader term. Similarly, '{ei : \u2211j A(P1)[i,j] > 0 and 1 \u2264 j \u2264 n}' also has a broader term. Queries about the country where Celine Dion was president have a broader term as well. Counting numerical values like '0.45' or 'n' can be seen as having a broader term too. Experimental settings designed to facilitate experimentation and data collection, on the other hand, are described using parameters that define specific conditions. The city or location where someone studied is also related to variables. In addition, pairwise local fitness functions defined accordingly have a broader term in terms of definition. References like '(3)' and '(4)' can be seen as having a broader term too. Countries with distinct governments and borders are described using relations that connect them.",
    "The two predicates 'liveIn(e'', e)' and 'locatedIn(e', e')' that may co-occur because they share similar entities, such as cities. Predicates are mathematical concepts or logical operators defining relationships between entities. The confidence degree measures the level of certainty in a particular outcome or prediction. A fact is a statement providing evidence for something. In Wikidata, multilingual refers to languages used to describe data. 'Poker Hand' describes Class attributes like suit and rank. Techniques involve building methods to achieve specific goals.",
    "The concept of standard confidence measures has been applied to evaluate various metrics, including cardinality and count. The subject argument of a head predicate can be an input or participant involved with the main action described by the predicate. In this context, citizenOf(x,y) represents a relationship between an individual's citizenship and their place of residence. Elsevier Inc., as a publisher, has published articles on various topics, including evaluation methods and building techniques. The maximum rule length is set to ensure that rules are not too complex or convoluted. Furthermore, the setting in which these experiments were conducted was crucial for obtaining accurate results.",
    "The novel components introduced by We are located within places, which can be situated within other relations. The Class attribute that describes a Poker Hand has a broader term of 'Class attribute'. Inference allows us to query citizenOf(Bronte, ?) and infer facts about someone's city of residence and nation. Building methods involve constructing or developing something in a specific way. CitizenOf is a relation indicating citizenship in a particular country or jurisdiction. An entity e can be defined as an instance with a count that represents its cardinality. Participants are involved in events or activities, which have instances and counts. Movies produced in some countries are products of the film industry. Each participant has a broader term of 'Definition'.",
    "Sam, who can be inferred to be a citizen of an unknown country (?), studied at z. The city or location where someone studies has its own set of relations with other entities. In this context, Sam's place of residence was y, which shares a relationship with the quantity or measure of entities in a given set, often used to describe the size or magnitude of that set (cardinality). Additionally, there were participants involved in TV programs possibly with occupations at z and y. Furthermore, we can infer that someone is a user who interacts with systems, services, or applications. The head of state or government in a country was also present, along with definitions explaining the meaning behind certain concepts. In this scenario, experimental settings were used to assess rule quality based on standard confidence (SC) measures and targets set by our objective.",
    "The concept of predicates defines relationships between entities, such as placeOfBirth and locatedIn. A participant or individual can be involved in a TV program, possibly with an occupation. Nations are sovereign territorial entities with their own governments. The highest point represents the maximum extent of something. Measures quantify indicators used for evaluation purposes, while confidence measures the degree of certainty. The isBornIn relation connects individuals to their birthplaces. Run times measure the duration or pace at which a process executes. Targets represent points aimed at being achieved. Countries are sovereign states with defined borders and governments. Heads serve as central components or focal points. Someone refers to a human being with their own identity, characteristics, and experiences. The isCitizenOf relation indicates an individual's citizenship in a particular country. Continents are large continuous areas of land. Wikipedia provides access to vast repositories of knowledge on various topics.",
    "We used the Max operator to analyze two sets of experiments, one conducted by Sam and another by Obama. The participants involved were Bronte from Canberra, Australia, who livedIn( x, z ) at a city that was often referred to as e, which could be either a place or a person. In both cases, e is often a city located in a country\u207b\u00b9(). This begs the question: what are the relevant questions we should ask about these experiments and their findings?",
    "The concept of Standard confidence (SC) provides a measure of certainty or reliability. It has a broader term, Definition, which offers a concise explanation or statement of meaning. Parameters define specific settings or conditions and have a broader term in setting. Countries are sovereign states with defined borders and governments, having a broader term as places. A place or person can be located within another entity, represented by the relationship 'locatedIn'. The concept that if an entity lives in z then it is a citizen of somewhere (t) has a broader term Definition. Participants involved in activities have a broader term participant. USA, being a country, has a broader term as countries and also relates to someone who can be a presenter or a person with relations. Someone's location can be represented by y which has a broader term place. The concept that has a participant (w) is related to someone who lives in z. Obama, the 44th President of the United States, has a broader term as someone. Facts provide evidence and support for events or statements.",
    "The set of entities related to the target predicate, including those directly connected and indirectly linked through other predicates. The TV program (z) has a broader term 'TV program', which represents a scheduled series of television content featuring scripted or unscripted programming, entertainment, and information. Ann is someone who lives in Canberra, Australia, and Obama was the 44th President of the United States. Additionally, there are rules governing the likelihood of knowing an individual's place of birth based on information about their spouse.",
    "According to our findings, individuals can be citizens of somewhere (y), with their citizenship being a legal status or affiliation granted by a country. We authors have studied and contributed to scholarly works on this topic. A person's spouse is often considered part of their relations, which are connections between entities. The city of residence is typically located within a nation, such as the USA, Australia, or other countries. Experimental settings can be controlled environments designed for data collection. In our research, we have found that individuals like Bronte live in cities and nations, with some being born in specific places. Facts about these relationships provide evidence to support our findings.",
    "Barack Obama, the 44th President of the United States, was born in a place that is likely to be located somewhere. As an individual with personal characteristics (z), he has a spouse who shares his citizenship and nationality. The city where Obama resides, Canberra, is situated within Australia, which is also home to Bronte, another Australian Rules footballer from Canberra. It's interesting to note that the place of birth for someone like Obama can be found in their country of origin or nation. Furthermore, a person's city of residence and the nation they reside in are often closely tied together.",
    "The Australian National University, or ANU for short, has a student named Sam who studies there. Bronte, an individual from Canberra, holds citizenship of Australia and resides in that city. It's likely that their place of birth is also located in Canberra. Interestingly, Celine Dion, the famous singer-songwriter, shares some commonalities with someone else - perhaps even Bronte himself! Meanwhile, Sam has a spouse who may or may not be from Canberra. In any case, Australia serves as the backdrop for many of these individuals' lives and experiences."
  ],
  "times": [
    2521.6787292957306
  ]
}